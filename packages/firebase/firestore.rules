rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    function authed() { return request.auth != null; }
    function self(u) { return authed() && u == request.auth.uid; }
    function validClip(clip) {
      return clip.keys().hasAll(['url', 'duration', 'ts']) &&
             clip.duration is number && clip.duration <= 15 &&
             clip.url is string && clip.url.matches('gs://.*') &&
             clip.ts is timestamp;
    }

    match /users/{u} {
      allow read: if authed();
      allow create, update: if self(u) && 
        request.resource.data.handle is string && 
        request.resource.data.handle.size() <= 20 &&
        request.resource.data.stance in ['regular', 'goofy'];
      // Allow users to update their own cooldownUntil field
      allow update: if self(u) && 
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['cooldownUntil']);
    }

    match /challenges/{c} {
      allow read: if authed();
      allow create: if authed() &&
        request.resource.data.rules.oneTake == true &&
        request.resource.data.rules.durationSec == 15 &&
        request.resource.data.createdBy == request.auth.uid &&
        request.resource.data.opponent is string &&
        validClip(request.resource.data.clipA) &&
        request.resource.data.status == 'pending' &&
        !request.resource.data.keys().hasAny(['winner', 'deadline']);
      allow update: if authed() &&
        (resource.data.createdBy == request.auth.uid || resource.data.opponent == request.auth.uid) &&
        resource.data.opponent == request.auth.uid &&
        !resource.data.keys().hasAll(['clipB']) &&
        request.resource.data.keys().hasAll(['clipB']) &&
        validClip(request.resource.data.clipB) &&
        request.resource.data.status == resource.data.status &&
        (!request.resource.data.keys().hasAny(['winner']) || request.resource.data.winner == resource.data.winner) &&
        (!request.resource.data.keys().hasAny(['deadline']) || request.resource.data.deadline == resource.data.deadline);
    }

    match /spots/{s} {
      allow read: if true;
      allow write: if false;
    }

    match /checkins/{c} {
      allow read: if authed();
      allow create: if authed() &&
        request.resource.data.uid == request.auth.uid &&
        request.resource.data.proofVideoUrl is string &&
        request.resource.data.geo.lat is number && 
        request.resource.data.geo.lng is number;
    }

    match /wallets/{u} {
      allow read, update: if self(u);
      allow create: if false;
    }

    match /closet/{u}/items/{i} {
      allow read, create, delete: if self(u) &&
        request.resource.data.type in ['top', 'bottom', 'deck', 'hardware'] &&
        request.resource.data.brand is string;
    }

    // infra/firebase/rules.skate.ts
    match /skate_games/{gameId} {
      allow read: if authed();
      allow create: if authed() 
        && request.resource.data.challengerUid == request.auth.uid
        && request.resource.data.status == 'pending'
        && request.resource.data.letters.challenger == ''
        && request.resource.data.letters.opponent == ''
        && request.resource.data.currentTurnType == 'setTrick';
      
      allow update: if authed()
        && (
          // Setting first trick
          (request.resource.data.currentTurnType == 'setTrick'
           && request.resource.data.currentTrickVideoUrl != null
           && resource.data.currentTurnType == 'setTrick')
          
          // Attempting to match
          || (request.resource.data.currentTurnType == 'attemptMatch'
              && request.resource.data.pendingAttemptVideoUrl != null
              && request.auth.uid == resource.data.opponentUid)
              
          // Self-judging (honor system)
          || (request.resource.data.diff( resource.data ).affectedKeys().hasOnly(['letters', 'currentTurnUid', 'currentTurnType', 'winnerUid', 'status'])
              && request.auth.uid in [resource.data.challengerUid, resource.data.opponentUid])
        );
    }

    // --- V2 Core Loop: Submissions Queue & Judge System ---
    // Submissions are the core of the new judging workflow
    match /submissions/{submissionId} {
      // Allow authenticated users to create a new submission.
      // This is where we enforce the "no re-dos" cooldown rule.
      allow create: if authed()
        && isUserOffCooldown(request.auth.uid)
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.challengeId is string
        && request.resource.data.gameLength in ['SKATE', 'SK8']
        && request.resource.data.videoURL is string
        && request.resource.data.status == 'PENDING'
        && request.resource.data.judging.landedVotes == 0
        && request.resource.data.judging.letterVotes == 0
        && request.resource.data.judging.disputeVotes == 0
        && request.resource.data.judging.judgesVoted.size() == 0
        && request.resource.data.submittedAt is timestamp;

      // Only designated judges can update a submission (for voting).
      allow update: if isJudge()
        && resource.data.status == 'PENDING'
        && !resource.data.judging.judgesVoted.hasAny([request.auth.uid])
        && isValidJudgeUpdate();

      // Read access for the original user and judges
      allow read: if authed()
        && (resource.data.userId == request.auth.uid || isJudge());

      allow delete: if false; // Submissions are immutable
    }

    // --- Helper Functions for V2 Core Loop ---
    
    // Checks if the user's cooldown period has expired
    function isUserOffCooldown(userId) {
      let userDoc = get(/databases/$(database)/documents/users/$(userId)).data;
      return !('cooldownUntil' in userDoc) || !(userDoc.cooldownUntil is timestamp) || userDoc.cooldownUntil <= request.time;
    }

    // Checks if the authenticated user is a designated judge
    function isJudge() {
      let userDoc = get(/databases/$(database)/documents/users/$(request.auth.uid)).data;
      return 'isJudge' in userDoc && userDoc.isJudge == true;
    }

    // Ensures judges only modify voting-related fields
    function isValidJudgeUpdate() {
      return request.resource.data.keys().size() == resource.data.keys().size()
        && request.resource.data.userId == resource.data.userId
        && request.resource.data.challengeId == resource.data.challengeId
        && request.resource.data.gameLength == resource.data.gameLength
        && request.resource.data.videoURL == resource.data.videoURL
        && request.resource.data.submittedAt == resource.data.submittedAt;
    }
  }
}
