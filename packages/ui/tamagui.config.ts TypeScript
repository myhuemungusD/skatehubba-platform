// src/lib.rs – SkateHubba Heshur AI • Rust transcoder module (Phase 1: Safe Stub)
// Goal: Provide a safe C-FFI boundary for hardware-accelerated video processing.
// Target: <1.8s 720p→15s clip using VAAPI/Metal/VideoToolbox/MediaCodec.

use std::ffi::{c_char, CStr};
use std::panic;

// ── FFI Contract Error Codes ──────────────────────────────────────────
const SUCCESS: i32 = 0;
const FALLBACK_TO_FFMPEGKIT: i32 = -1; // Intentional Phase 1 fallback
const ERR_NULL_POINTER: i32 = -2;
const ERR_INVALID_UTF8: i32 = -3;
const ERR_RUST_PANIC: i32 = -99; // Sentinel for Sentry logging

// ── Safety first: never let a Rust panic cross the FFI boundary ──
fn catch_unwind<F: FnOnce() -> i32 + std::panic::UnwindSafe>(f: F) -> i32 {
    match panic::catch_unwind(f) {
        Ok(code) => code,
        Err(_) => {
            eprintln!("transcode_15s: Rust panic caught at FFI boundary");
            ERR_RUST_PANIC
        }
    }
}

// ── FFI Function: Transcodes a video clip to 15 seconds ────────────────
#[no_mangle]
pub extern "C" fn transcode_15s(
    input_path: *const c_char,
    output_path: *const c_char,
) -> i32 {
    catch_unwind(|| {
        // 1. Null pointer guards (Mandatory FFI safety)
        if input_path.is_null() || output_path.is_null() {
            eprintln!("transcode_15s: null pointer passed");
            return ERR_NULL_POINTER;
        }

        // 2. Safe CStr -> Rust &str conversion
        let input = match unsafe { CStr::from_ptr(input_path) }.to_str() {
            Ok(s) => s,
            Err(_) => {
                eprintln!("transcode_15s: input_path invalid UTF-8");
                return ERR_INVALID_UTF8;
            }
        };

        let output = match unsafe { CStr::from_ptr(output_path) }.to_str() {
            Ok(s) => s,
            Err(_) => {
                eprintln!("transcode_15s: output_path invalid UTF-8");
                return ERR_INVALID_UTF8;
            }
        };

        // 3. Phase 1 Stub Logic (Current)
        eprintln!(
            "transcode_15s stub called → input: {} | output: {}",
            input, output
        );

        // Signal to the TypeScript/Native layer to use the FFmpegKit fallback.
        FALLBACK_TO_FFMPEGKIT
    })
}

// ── FFI Function: Returns the current transcoder feature level ──────────
#[no_mangle]
pub extern "C" fn heshur_transcoder_version() -> i32 {
    // Version format: major * 10000 + minor * 100 + patch
    // 0.1.0 → 100 (This indicates Phase 1: Stub)
    100 
}
