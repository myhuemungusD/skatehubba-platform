"use strict";

import HoneycombOpentelemetryReactNative from './NativeHoneycombOpentelemetryReactNative';
import { HoneycombWebSDK } from '@honeycombio/opentelemetry-web';
import { FetchInstrumentation } from '@opentelemetry/instrumentation-fetch';
import { ReactNativeStartupInstrumentation } from "./ReactNativeStartupInstrumentation.js";
import { UncaughtExceptionInstrumentation } from "./UncaughtExceptionInstrumentation.js";
import { resourceFromAttributes } from '@opentelemetry/resources';
import { RandomIdGenerator } from '@opentelemetry/sdk-trace-base';
import { ATTR_OS_NAME, ATTR_OS_VERSION, ATTR_TELEMETRY_DISTRO_NAME, ATTR_TELEMETRY_DISTRO_VERSION, ATTR_TELEMETRY_SDK_LANGUAGE, ATTR_TELEMETRY_SDK_NAME, ATTR_TELEMETRY_SDK_VERSION, ATTR_DEPLOYMENT_ENVIRONMENT_NAME } from '@opentelemetry/semantic-conventions/incubating';
import { VERSION } from "./version.js";
import { SlowEventLoopInstrumentation } from "./SlowEventLoopInstrumentation.js";
export { NavigationInstrumentation } from "./NavigationInstrumentation.js";
export { ReactNativeStartupInstrumentation } from "./ReactNativeStartupInstrumentation.js";
export { SlowEventLoopInstrumentation } from "./SlowEventLoopInstrumentation.js";
export { UncaughtExceptionInstrumentation } from "./UncaughtExceptionInstrumentation.js";
import { Platform } from 'react-native';
const generator = new RandomIdGenerator();
const defaultSessionId = generator.generateTraceId();

// By default, we include a SessionIdProvider that uses the native session ID,
// if possible. Otherwise, it falls back with a reasonable default.
class SessionIdProvider {
  getSessionId() {
    const nativeSessionId = HoneycombOpentelemetryReactNative.getSessionId();
    if (nativeSessionId) {
      return nativeSessionId;
    }
    return defaultSessionId;
  }
}

/**
 * The options used to configure the Honeycomb React Native SDK.
 */

const reactNativeOSTypeToOtelOSName = {
  ios: 'iOS',
  android: 'Android',
  macos: 'macOS',
  native: 'Native',
  web: 'Web',
  windows: 'windows'
};
function getOSName() {
  return reactNativeOSTypeToOtelOSName[Platform.OS];
}

/**
 * The entry point to Honeycomb in React Native apps.
 */
export class HoneycombReactNativeSDK extends HoneycombWebSDK {
  constructor(options) {
    const instrumentations = [...(options?.instrumentations || [])];
    if (options?.reactNativeStartupInstrumentationConfig?.enabled !== false) {
      instrumentations.push(new ReactNativeStartupInstrumentation(options?.reactNativeStartupInstrumentationConfig));
    }
    if (options?.fetchInstrumentationConfig?.enabled !== false) {
      instrumentations.push(new FetchInstrumentation(options?.fetchInstrumentationConfig));
    }
    if (options?.uncaughtExceptionInstrumentationConfig?.enabled !== false) {
      instrumentations.push(new UncaughtExceptionInstrumentation(options?.uncaughtExceptionInstrumentationConfig));
    }
    const {
      major,
      minor,
      patch,
      prerelease
    } = Platform.constants.reactNativeVersion;
    let reactNativeVersion = `${major}.${minor}.${patch}`;
    if (prerelease) {
      reactNativeVersion = `${reactNativeVersion}-${[prerelease]}`;
    }

    // If the native SDKs are not initialized, fall back the the RN furnished values
    const nativeAttributes = HoneycombOpentelemetryReactNative.getResource();
    if (!nativeAttributes[ATTR_OS_NAME]) {
      nativeAttributes[ATTR_OS_NAME] = getOSName();
    }
    if (!nativeAttributes[ATTR_OS_VERSION]) {
      nativeAttributes[ATTR_OS_VERSION] = Platform.Version;
    }
    const attributes = {
      ...nativeAttributes,
      // Honeycomb distro attributes,
      'honeycomb.distro.version': VERSION,
      'honeycomb.distro.runtime_version': reactNativeVersion,
      // Opentelemetry attributes
      [ATTR_TELEMETRY_DISTRO_NAME]: '@honeycombio/opentelemetry-react-native',
      [ATTR_TELEMETRY_DISTRO_VERSION]: VERSION,
      [ATTR_TELEMETRY_SDK_LANGUAGE]: 'hermesjs',
      [ATTR_TELEMETRY_SDK_NAME]: 'opentelemetry',
      [ATTR_TELEMETRY_SDK_VERSION]: VERSION,
      // React Native enviornment
      [ATTR_DEPLOYMENT_ENVIRONMENT_NAME]: __DEV__ ? 'development' : 'production'
    };
    const sourceMapUuid = HoneycombOpentelemetryReactNative.getDebugSourceMapUUID();
    if (sourceMapUuid) {
      attributes['app.debug.source_map_uuid'] = sourceMapUuid;
    }
    let resource = resourceFromAttributes(attributes);
    if (options?.resource) {
      resource = resource.merge(options.resource);
    }
    if (options?.slowEventLoopInstrumentationConfig?.enabled !== false) {
      instrumentations.push(new SlowEventLoopInstrumentation(options?.slowEventLoopInstrumentationConfig));
    }
    super({
      ...options,
      // Add default instrumentations
      instrumentations,
      resource,
      // Override web options that make no sense for React Native.
      disableBrowserAttributes: true,
      sessionProvider: new SessionIdProvider(),
      webVitalsInstrumentationConfig: {
        enabled: false
      },
      globalErrorsInstrumentationConfig: {
        enabled: false
      }
    });
  }
}
//# sourceMappingURL=index.js.map