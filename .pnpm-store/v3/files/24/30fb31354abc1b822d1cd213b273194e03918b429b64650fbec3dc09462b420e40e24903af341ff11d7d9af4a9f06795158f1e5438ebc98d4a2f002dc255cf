"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SlowEventLoopInstrumentation = void 0;
var _instrumentation = require("@opentelemetry/instrumentation");
var _version = require("./version.js");
var _reactNative = require("react-native");
const LIBRARY_NAME = '@honeycombio/slow-event-loop';
const DEFAULT_LOOP_SAMPLE_INTERVAL_MS = 50;
const DEFAULT_STALL_THRESHOLD_MS = 50;
class SlowEventLoopInstrumentation extends _instrumentation.InstrumentationBase {
  _lastLoopTimestamp = 0;
  _intervalRef = null;
  _appStateRef = null;
  constructor({
    enabled = true,
    loopSampleIntervalMs = DEFAULT_LOOP_SAMPLE_INTERVAL_MS,
    stallThresholdMs = DEFAULT_STALL_THRESHOLD_MS,
    applyCustomAttributesOnSpan
  } = {}) {
    const config = {
      enabled,
      applyCustomAttributesOnSpan
    };
    super(LIBRARY_NAME, _version.VERSION, config);
    this._loopSampleIntervalMs = loopSampleIntervalMs;
    this._stallThresholdMs = stallThresholdMs;
    this._isAppSuspended = false;
    if (enabled) {
      this.enable();
    }
    this._isEnabled = enabled;
    this.applyCustomAttributesOnSpan = applyCustomAttributesOnSpan;
  }
  enable() {
    if (this._isEnabled) {
      this._diag.debug('Instrumentation already enabled');
    }
    if (_reactNative.AppState?.isAvailable) {
      this._appStateRef = _reactNative.AppState.addEventListener('change', this._suspendResumeHandler.bind(this));
    }
    this._lastLoopTimestamp = Date.now();
    this._isEnabled = true;
    this._intervalRef = setInterval(this._checkEventLoop.bind(this), this._loopSampleIntervalMs);
  }
  disable() {
    if (!this._isEnabled) {
      this._diag.debug('Instrumentation already disabled');
    }
    this._isEnabled = false;
    if (this._intervalRef !== null) {
      clearInterval(this._intervalRef);
    }
    if (this._appStateRef !== null) {
      this._appStateRef?.remove();
    }
  }
  init() {}
  _checkEventLoop() {
    const nowTimestamp = Date.now();
    const intervalSinceLastCheck = nowTimestamp - this._lastLoopTimestamp;
    if (intervalSinceLastCheck >= this._loopSampleIntervalMs + this._stallThresholdMs) {
      this._emitSlowEventLoopSpan({
        delayMs: intervalSinceLastCheck,
        timestampMs: this._lastLoopTimestamp
      });
    }
    this._lastLoopTimestamp = nowTimestamp;
    if (!this._isEnabled || this._isAppSuspended) {
      if (this._intervalRef) {
        clearInterval(this._intervalRef);
      }
    }
  }
  _emitSlowEventLoopSpan({
    delayMs,
    timestampMs
  }) {
    const slowEventLoopSpan = this.tracer.startSpan('slow event loop', {
      startTime: timestampMs
    });

    // hermes is not listed in the JS semantic conventions so we
    // are going to use the `hermes` namespace and the node/web/v8 naming convention
    slowEventLoopSpan.setAttribute('hermes.eventloop.delay', delayMs);
    if (this.applyCustomAttributesOnSpan) {
      this.applyCustomAttributesOnSpan(slowEventLoopSpan, {
        delayMs,
        timestampMs
      });
    }
    slowEventLoopSpan.end(timestampMs + delayMs);
  }
  _suspendResumeHandler(appState) {
    if (appState === 'active') {
      this._isAppSuspended = false;
      if (this._isEnabled && this._intervalRef === null) {
        this._lastLoopTimestamp = Date.now();
        this._intervalRef = setInterval(this._checkEventLoop.bind(this), this._loopSampleIntervalMs);
      }
    } else {
      this._isAppSuspended = true;
      if (this._intervalRef !== null) {
        clearInterval(this._intervalRef);
      }
    }
  }
}
exports.SlowEventLoopInstrumentation = SlowEventLoopInstrumentation;
//# sourceMappingURL=SlowEventLoopInstrumentation.js.map