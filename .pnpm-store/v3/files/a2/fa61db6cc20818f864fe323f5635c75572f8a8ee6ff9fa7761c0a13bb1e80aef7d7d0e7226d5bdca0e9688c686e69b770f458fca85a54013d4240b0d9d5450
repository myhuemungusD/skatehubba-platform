'use strict';

var api = require('@opentelemetry/api');
var instrumentation = require('@opentelemetry/instrumentation');
var resources = require('@opentelemetry/resources');
var sdkTraceBase = require('@opentelemetry/sdk-trace-base');
var sdkTraceWeb = require('@opentelemetry/sdk-trace-web');
var semanticConventions = require('@opentelemetry/semantic-conventions');
var opentelemetryBrowserDetector = require('@opentelemetry/opentelemetry-browser-detector');
var core = require('@opentelemetry/core');
var userInteractionInstrumentation = require('./user-interaction-instrumentation-qqYujxvd.js');
var shimmer = require('shimmer');
var tracekit = require('tracekit');
var exporterTraceOtlpHttp = require('@opentelemetry/exporter-trace-otlp-http');
var exporterMetricsOtlpHttp = require('@opentelemetry/exporter-metrics-otlp-http');
var exporterLogsOtlpHttp = require('@opentelemetry/exporter-logs-otlp-http');
var webCommon = require('@opentelemetry/web-common');
var UAParser = require('ua-parser-js');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var api__namespace = /*#__PURE__*/_interopNamespaceDefault(api);
var shimmer__namespace = /*#__PURE__*/_interopNamespaceDefault(shimmer);

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * AggregationTemporality indicates the way additive quantities are expressed.
 */
var AggregationTemporality;
(function (AggregationTemporality) {
  AggregationTemporality[AggregationTemporality["DELTA"] = 0] = "DELTA";
  AggregationTemporality[AggregationTemporality["CUMULATIVE"] = 1] = "CUMULATIVE";
})(AggregationTemporality || (AggregationTemporality = {}));

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Supported types of metric instruments.
 */
var InstrumentType;
(function (InstrumentType) {
  InstrumentType["COUNTER"] = "COUNTER";
  InstrumentType["GAUGE"] = "GAUGE";
  InstrumentType["HISTOGRAM"] = "HISTOGRAM";
  InstrumentType["UP_DOWN_COUNTER"] = "UP_DOWN_COUNTER";
  InstrumentType["OBSERVABLE_COUNTER"] = "OBSERVABLE_COUNTER";
  InstrumentType["OBSERVABLE_GAUGE"] = "OBSERVABLE_GAUGE";
  InstrumentType["OBSERVABLE_UP_DOWN_COUNTER"] = "OBSERVABLE_UP_DOWN_COUNTER";
})(InstrumentType || (InstrumentType = {}));
/**
 * The aggregated point data type.
 */
var DataPointType;
(function (DataPointType) {
  /**
   * A histogram data point contains a histogram statistics of collected
   * values with a list of explicit bucket boundaries and statistics such
   * as min, max, count, and sum of all collected values.
   */
  DataPointType[DataPointType["HISTOGRAM"] = 0] = "HISTOGRAM";
  /**
   * An exponential histogram data point contains a histogram statistics of
   * collected values where bucket boundaries are automatically calculated
   * using an exponential function, and statistics such as min, max, count,
   * and sum of all collected values.
   */
  DataPointType[DataPointType["EXPONENTIAL_HISTOGRAM"] = 1] = "EXPONENTIAL_HISTOGRAM";
  /**
   * A gauge metric data point has only a single numeric value.
   */
  DataPointType[DataPointType["GAUGE"] = 2] = "GAUGE";
  /**
   * A sum metric data point has a single numeric value and a
   * monotonicity-indicator.
   */
  DataPointType[DataPointType["SUM"] = 3] = "SUM";
})(DataPointType || (DataPointType = {}));

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function isNotNullish(item) {
  return item !== undefined && item !== null;
}
/**
 * Converting the unordered attributes into unique identifier string.
 * @param attributes user provided unordered Attributes.
 */
function hashAttributes(attributes) {
  let keys = Object.keys(attributes);
  if (keys.length === 0) return '';
  // Return a string that is stable on key orders.
  keys = keys.sort();
  return JSON.stringify(keys.map(key => [key, attributes[key]]));
}
/**
 * Converting the instrumentation scope object to a unique identifier string.
 * @param instrumentationScope
 */
function instrumentationScopeId(instrumentationScope) {
  return `${instrumentationScope.name}:${instrumentationScope.version ?? ''}:${instrumentationScope.schemaUrl ?? ''}`;
}
/**
 * Error that is thrown on timeouts.
 */
class TimeoutError extends Error {
  constructor(message) {
    super(message);
    // manually adjust prototype to retain `instanceof` functionality when targeting ES5, see:
    // https://github.com/Microsoft/TypeScript-wiki/blob/main/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work
    Object.setPrototypeOf(this, TimeoutError.prototype);
  }
}
/**
 * Adds a timeout to a promise and rejects if the specified timeout has elapsed. Also rejects if the specified promise
 * rejects, and resolves if the specified promise resolves.
 *
 * <p> NOTE: this operation will continue even after it throws a {@link TimeoutError}.
 *
 * @param promise promise to use with timeout.
 * @param timeout the timeout in milliseconds until the returned promise is rejected.
 */
function callWithTimeout(promise, timeout) {
  let timeoutHandle;
  const timeoutPromise = new Promise(function timeoutFunction(_resolve, reject) {
    timeoutHandle = setTimeout(function timeoutHandler() {
      reject(new TimeoutError('Operation timed out.'));
    }, timeout);
  });
  return Promise.race([promise, timeoutPromise]).then(result => {
    clearTimeout(timeoutHandle);
    return result;
  }, reason => {
    clearTimeout(timeoutHandle);
    throw reason;
  });
}
/**
 * Node.js v12.9 lower and browser compatible `Promise.allSettled`.
 */
async function PromiseAllSettled(promises) {
  return Promise.all(promises.map(async p => {
    try {
      const ret = await p;
      return {
        status: 'fulfilled',
        value: ret
      };
    } catch (e) {
      return {
        status: 'rejected',
        reason: e
      };
    }
  }));
}
function isPromiseAllSettledRejectionResult(it) {
  return it.status === 'rejected';
}
/**
 * Node.js v11.0 lower and browser compatible `Array.prototype.flatMap`.
 */
function FlatMap(arr, fn) {
  const result = [];
  arr.forEach(it => {
    result.push(...fn(it));
  });
  return result;
}
function setEquals(lhs, rhs) {
  if (lhs.size !== rhs.size) {
    return false;
  }
  for (const item of lhs) {
    if (!rhs.has(item)) {
      return false;
    }
  }
  return true;
}
/**
 * Binary search the sorted array to the find upper bound for the value.
 * @param arr
 * @param value
 * @returns
 */
function binarySearchUB(arr, value) {
  let lo = 0;
  let hi = arr.length - 1;
  let ret = arr.length;
  while (hi >= lo) {
    const mid = lo + Math.trunc((hi - lo) / 2);
    if (arr[mid] < value) {
      lo = mid + 1;
    } else {
      ret = mid;
      hi = mid - 1;
    }
  }
  return ret;
}
function equalsCaseInsensitive(lhs, rhs) {
  return lhs.toLowerCase() === rhs.toLowerCase();
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** The kind of aggregator. */
var AggregatorKind;
(function (AggregatorKind) {
  AggregatorKind[AggregatorKind["DROP"] = 0] = "DROP";
  AggregatorKind[AggregatorKind["SUM"] = 1] = "SUM";
  AggregatorKind[AggregatorKind["LAST_VALUE"] = 2] = "LAST_VALUE";
  AggregatorKind[AggregatorKind["HISTOGRAM"] = 3] = "HISTOGRAM";
  AggregatorKind[AggregatorKind["EXPONENTIAL_HISTOGRAM"] = 4] = "EXPONENTIAL_HISTOGRAM";
})(AggregatorKind || (AggregatorKind = {}));

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** Basic aggregator for None which keeps no recorded value. */
class DropAggregator {
  kind = AggregatorKind.DROP;
  createAccumulation() {
    return undefined;
  }
  merge(_previous, _delta) {
    return undefined;
  }
  diff(_previous, _current) {
    return undefined;
  }
  toMetricData(_descriptor, _aggregationTemporality, _accumulationByAttributes, _endTime) {
    return undefined;
  }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function createNewEmptyCheckpoint(boundaries) {
  const counts = boundaries.map(() => 0);
  counts.push(0);
  return {
    buckets: {
      boundaries,
      counts
    },
    sum: 0,
    count: 0,
    hasMinMax: false,
    min: Infinity,
    max: -Infinity
  };
}
class HistogramAccumulation {
  startTime;
  _boundaries;
  _recordMinMax;
  _current;
  constructor(startTime, _boundaries, _recordMinMax = true, _current = createNewEmptyCheckpoint(_boundaries)) {
    this.startTime = startTime;
    this._boundaries = _boundaries;
    this._recordMinMax = _recordMinMax;
    this._current = _current;
  }
  record(value) {
    // NaN does not fall into any bucket, is not zero and should not be counted,
    // NaN is never greater than max nor less than min, therefore return as there's nothing for us to do.
    if (Number.isNaN(value)) {
      return;
    }
    this._current.count += 1;
    this._current.sum += value;
    if (this._recordMinMax) {
      this._current.min = Math.min(value, this._current.min);
      this._current.max = Math.max(value, this._current.max);
      this._current.hasMinMax = true;
    }
    const idx = binarySearchUB(this._boundaries, value);
    this._current.buckets.counts[idx] += 1;
  }
  setStartTime(startTime) {
    this.startTime = startTime;
  }
  toPointValue() {
    return this._current;
  }
}
/**
 * Basic aggregator which observes events and counts them in pre-defined buckets
 * and provides the total sum and count of all observations.
 */
class HistogramAggregator {
  _boundaries;
  _recordMinMax;
  kind = AggregatorKind.HISTOGRAM;
  /**
   * @param _boundaries sorted upper bounds of recorded values.
   * @param _recordMinMax If set to true, min and max will be recorded. Otherwise, min and max will not be recorded.
   */
  constructor(_boundaries, _recordMinMax) {
    this._boundaries = _boundaries;
    this._recordMinMax = _recordMinMax;
  }
  createAccumulation(startTime) {
    return new HistogramAccumulation(startTime, this._boundaries, this._recordMinMax);
  }
  /**
   * Return the result of the merge of two histogram accumulations. As long as one Aggregator
   * instance produces all Accumulations with constant boundaries we don't need to worry about
   * merging accumulations with different boundaries.
   */
  merge(previous, delta) {
    const previousValue = previous.toPointValue();
    const deltaValue = delta.toPointValue();
    const previousCounts = previousValue.buckets.counts;
    const deltaCounts = deltaValue.buckets.counts;
    const mergedCounts = new Array(previousCounts.length);
    for (let idx = 0; idx < previousCounts.length; idx++) {
      mergedCounts[idx] = previousCounts[idx] + deltaCounts[idx];
    }
    let min = Infinity;
    let max = -Infinity;
    if (this._recordMinMax) {
      if (previousValue.hasMinMax && deltaValue.hasMinMax) {
        min = Math.min(previousValue.min, deltaValue.min);
        max = Math.max(previousValue.max, deltaValue.max);
      } else if (previousValue.hasMinMax) {
        min = previousValue.min;
        max = previousValue.max;
      } else if (deltaValue.hasMinMax) {
        min = deltaValue.min;
        max = deltaValue.max;
      }
    }
    return new HistogramAccumulation(previous.startTime, previousValue.buckets.boundaries, this._recordMinMax, {
      buckets: {
        boundaries: previousValue.buckets.boundaries,
        counts: mergedCounts
      },
      count: previousValue.count + deltaValue.count,
      sum: previousValue.sum + deltaValue.sum,
      hasMinMax: this._recordMinMax && (previousValue.hasMinMax || deltaValue.hasMinMax),
      min: min,
      max: max
    });
  }
  /**
   * Returns a new DELTA aggregation by comparing two cumulative measurements.
   */
  diff(previous, current) {
    const previousValue = previous.toPointValue();
    const currentValue = current.toPointValue();
    const previousCounts = previousValue.buckets.counts;
    const currentCounts = currentValue.buckets.counts;
    const diffedCounts = new Array(previousCounts.length);
    for (let idx = 0; idx < previousCounts.length; idx++) {
      diffedCounts[idx] = currentCounts[idx] - previousCounts[idx];
    }
    return new HistogramAccumulation(current.startTime, previousValue.buckets.boundaries, this._recordMinMax, {
      buckets: {
        boundaries: previousValue.buckets.boundaries,
        counts: diffedCounts
      },
      count: currentValue.count - previousValue.count,
      sum: currentValue.sum - previousValue.sum,
      hasMinMax: false,
      min: Infinity,
      max: -Infinity
    });
  }
  toMetricData(descriptor, aggregationTemporality, accumulationByAttributes, endTime) {
    return {
      descriptor,
      aggregationTemporality,
      dataPointType: DataPointType.HISTOGRAM,
      dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => {
        const pointValue = accumulation.toPointValue();
        // determine if instrument allows negative values.
        const allowsNegativeValues = descriptor.type === InstrumentType.GAUGE || descriptor.type === InstrumentType.UP_DOWN_COUNTER || descriptor.type === InstrumentType.OBSERVABLE_GAUGE || descriptor.type === InstrumentType.OBSERVABLE_UP_DOWN_COUNTER;
        return {
          attributes,
          startTime: accumulation.startTime,
          endTime,
          value: {
            min: pointValue.hasMinMax ? pointValue.min : undefined,
            max: pointValue.hasMinMax ? pointValue.max : undefined,
            sum: !allowsNegativeValues ? pointValue.sum : undefined,
            buckets: pointValue.buckets,
            count: pointValue.count
          }
        };
      })
    };
  }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Buckets {
  backing;
  indexBase;
  indexStart;
  indexEnd;
  /**
   * The term index refers to the number of the exponential histogram bucket
   * used to determine its boundaries. The lower boundary of a bucket is
   * determined by base ** index and the upper boundary of a bucket is
   * determined by base ** (index + 1). index values are signed to account
   * for values less than or equal to 1.
   *
   * indexBase is the index of the 0th position in the
   * backing array, i.e., backing[0] is the count
   * in the bucket with index `indexBase`.
   *
   * indexStart is the smallest index value represented
   * in the backing array.
   *
   * indexEnd is the largest index value represented in
   * the backing array.
   */
  constructor(backing = new BucketsBacking(), indexBase = 0, indexStart = 0, indexEnd = 0) {
    this.backing = backing;
    this.indexBase = indexBase;
    this.indexStart = indexStart;
    this.indexEnd = indexEnd;
  }
  /**
   * Offset is the bucket index of the smallest entry in the counts array
   * @returns {number}
   */
  get offset() {
    return this.indexStart;
  }
  /**
   * Buckets is a view into the backing array.
   * @returns {number}
   */
  get length() {
    if (this.backing.length === 0) {
      return 0;
    }
    if (this.indexEnd === this.indexStart && this.at(0) === 0) {
      return 0;
    }
    return this.indexEnd - this.indexStart + 1;
  }
  /**
   * An array of counts, where count[i] carries the count
   * of the bucket at index (offset+i).  count[i] is the count of
   * values greater than base^(offset+i) and less than or equal to
   * base^(offset+i+1).
   * @returns {number} The logical counts based on the backing array
   */
  counts() {
    return Array.from({
      length: this.length
    }, (_, i) => this.at(i));
  }
  /**
   * At returns the count of the bucket at a position in the logical
   * array of counts.
   * @param position
   * @returns {number}
   */
  at(position) {
    const bias = this.indexBase - this.indexStart;
    if (position < bias) {
      position += this.backing.length;
    }
    position -= bias;
    return this.backing.countAt(position);
  }
  /**
   * incrementBucket increments the backing array index by `increment`
   * @param bucketIndex
   * @param increment
   */
  incrementBucket(bucketIndex, increment) {
    this.backing.increment(bucketIndex, increment);
  }
  /**
   * decrementBucket decrements the backing array index by `decrement`
   * if decrement is greater than the current value, it's set to 0.
   * @param bucketIndex
   * @param decrement
   */
  decrementBucket(bucketIndex, decrement) {
    this.backing.decrement(bucketIndex, decrement);
  }
  /**
   * trim removes leading and / or trailing zero buckets (which can occur
   * after diffing two histos) and rotates the backing array so that the
   * smallest non-zero index is in the 0th position of the backing array
   */
  trim() {
    for (let i = 0; i < this.length; i++) {
      if (this.at(i) !== 0) {
        this.indexStart += i;
        break;
      } else if (i === this.length - 1) {
        //the entire array is zeroed out
        this.indexStart = this.indexEnd = this.indexBase = 0;
        return;
      }
    }
    for (let i = this.length - 1; i >= 0; i--) {
      if (this.at(i) !== 0) {
        this.indexEnd -= this.length - i - 1;
        break;
      }
    }
    this._rotate();
  }
  /**
   * downscale first rotates, then collapses 2**`by`-to-1 buckets.
   * @param by
   */
  downscale(by) {
    this._rotate();
    const size = 1 + this.indexEnd - this.indexStart;
    const each = 1 << by;
    let inpos = 0;
    let outpos = 0;
    for (let pos = this.indexStart; pos <= this.indexEnd;) {
      let mod = pos % each;
      if (mod < 0) {
        mod += each;
      }
      for (let i = mod; i < each && inpos < size; i++) {
        this._relocateBucket(outpos, inpos);
        inpos++;
        pos++;
      }
      outpos++;
    }
    this.indexStart >>= by;
    this.indexEnd >>= by;
    this.indexBase = this.indexStart;
  }
  /**
   * Clone returns a deep copy of Buckets
   * @returns {Buckets}
   */
  clone() {
    return new Buckets(this.backing.clone(), this.indexBase, this.indexStart, this.indexEnd);
  }
  /**
   * _rotate shifts the backing array contents so that indexStart ==
   * indexBase to simplify the downscale logic.
   */
  _rotate() {
    const bias = this.indexBase - this.indexStart;
    if (bias === 0) {
      return;
    } else if (bias > 0) {
      this.backing.reverse(0, this.backing.length);
      this.backing.reverse(0, bias);
      this.backing.reverse(bias, this.backing.length);
    } else {
      // negative bias, this can happen when diffing two histograms
      this.backing.reverse(0, this.backing.length);
      this.backing.reverse(0, this.backing.length + bias);
    }
    this.indexBase = this.indexStart;
  }
  /**
   * _relocateBucket adds the count in counts[src] to counts[dest] and
   * resets count[src] to zero.
   */
  _relocateBucket(dest, src) {
    if (dest === src) {
      return;
    }
    this.incrementBucket(dest, this.backing.emptyBucket(src));
  }
}
/**
 * BucketsBacking holds the raw buckets and some utility methods to
 * manage them.
 */
class BucketsBacking {
  _counts;
  constructor(_counts = [0]) {
    this._counts = _counts;
  }
  /**
   * length returns the physical size of the backing array, which
   * is >= buckets.length()
   */
  get length() {
    return this._counts.length;
  }
  /**
   * countAt returns the count in a specific bucket
   */
  countAt(pos) {
    return this._counts[pos];
  }
  /**
   * growTo grows a backing array and copies old entries
   * into their correct new positions.
   */
  growTo(newSize, oldPositiveLimit, newPositiveLimit) {
    const tmp = new Array(newSize).fill(0);
    tmp.splice(newPositiveLimit, this._counts.length - oldPositiveLimit, ...this._counts.slice(oldPositiveLimit));
    tmp.splice(0, oldPositiveLimit, ...this._counts.slice(0, oldPositiveLimit));
    this._counts = tmp;
  }
  /**
   * reverse the items in the backing array in the range [from, limit).
   */
  reverse(from, limit) {
    const num = Math.floor((from + limit) / 2) - from;
    for (let i = 0; i < num; i++) {
      const tmp = this._counts[from + i];
      this._counts[from + i] = this._counts[limit - i - 1];
      this._counts[limit - i - 1] = tmp;
    }
  }
  /**
   * emptyBucket empties the count from a bucket, for
   * moving into another.
   */
  emptyBucket(src) {
    const tmp = this._counts[src];
    this._counts[src] = 0;
    return tmp;
  }
  /**
   * increments a bucket by `increment`
   */
  increment(bucketIndex, increment) {
    this._counts[bucketIndex] += increment;
  }
  /**
   * decrements a bucket by `decrement`
   */
  decrement(bucketIndex, decrement) {
    if (this._counts[bucketIndex] >= decrement) {
      this._counts[bucketIndex] -= decrement;
    } else {
      // this should not happen, but we're being defensive against
      // negative counts.
      this._counts[bucketIndex] = 0;
    }
  }
  /**
   * clone returns a deep copy of BucketsBacking
   */
  clone() {
    return new BucketsBacking([...this._counts]);
  }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The functions and constants in this file allow us to interact
 * with the internal representation of an IEEE 64-bit floating point
 * number. We need to work with all 64-bits, thus, care needs to be
 * taken when working with Javascript's bitwise operators (<<, >>, &,
 * |, etc) as they truncate operands to 32-bits. In order to work around
 * this we work with the 64-bits as two 32-bit halves, perform bitwise
 * operations on them independently, and combine the results (if needed).
 */
const SIGNIFICAND_WIDTH = 52;
/**
 * EXPONENT_MASK is set to 1 for the hi 32-bits of an IEEE 754
 * floating point exponent: 0x7ff00000.
 */
const EXPONENT_MASK = 0x7ff00000;
/**
 * SIGNIFICAND_MASK is the mask for the significand portion of the hi 32-bits
 * of an IEEE 754 double-precision floating-point value: 0xfffff
 */
const SIGNIFICAND_MASK = 0xfffff;
/**
 * EXPONENT_BIAS is the exponent bias specified for encoding
 * the IEEE 754 double-precision floating point exponent: 1023
 */
const EXPONENT_BIAS = 1023;
/**
 * MIN_NORMAL_EXPONENT is the minimum exponent of a normalized
 * floating point: -1022.
 */
const MIN_NORMAL_EXPONENT = -EXPONENT_BIAS + 1;
/**
 * MAX_NORMAL_EXPONENT is the maximum exponent of a normalized
 * floating point: 1023.
 */
const MAX_NORMAL_EXPONENT = EXPONENT_BIAS;
/**
 * MIN_VALUE is the smallest normal number
 */
const MIN_VALUE = Math.pow(2, -1022);
/**
 * getNormalBase2 extracts the normalized base-2 fractional exponent.
 * This returns k for the equation f x 2**k where f is
 * in the range [1, 2).  Note that this function is not called for
 * subnormal numbers.
 * @param {number} value - the value to determine normalized base-2 fractional
 *    exponent for
 * @returns {number} the normalized base-2 exponent
 */
function getNormalBase2(value) {
  const dv = new DataView(new ArrayBuffer(8));
  dv.setFloat64(0, value);
  // access the raw 64-bit float as 32-bit uints
  const hiBits = dv.getUint32(0);
  const expBits = (hiBits & EXPONENT_MASK) >> 20;
  return expBits - EXPONENT_BIAS;
}
/**
 * GetSignificand returns the 52 bit (unsigned) significand as a signed value.
 * @param {number} value - the floating point number to extract the significand from
 * @returns {number} The 52-bit significand
 */
function getSignificand(value) {
  const dv = new DataView(new ArrayBuffer(8));
  dv.setFloat64(0, value);
  // access the raw 64-bit float as two 32-bit uints
  const hiBits = dv.getUint32(0);
  const loBits = dv.getUint32(4);
  // extract the significand bits from the hi bits and left shift 32 places note:
  // we can't use the native << operator as it will truncate the result to 32-bits
  const significandHiBits = (hiBits & SIGNIFICAND_MASK) * Math.pow(2, 32);
  // combine the hi and lo bits and return
  return significandHiBits + loBits;
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Note: other languages provide this as a built in function. This is
 * a naive, but functionally correct implementation. This is used sparingly,
 * when creating a new mapping in a running application.
 *
 * ldexp returns frac × 2**exp. With the following special cases:
 *   ldexp(±0, exp) = ±0
 *   ldexp(±Inf, exp) = ±Inf
 *   ldexp(NaN, exp) = NaN
 * @param frac
 * @param exp
 * @returns {number}
 */
function ldexp(frac, exp) {
  if (frac === 0 || frac === Number.POSITIVE_INFINITY || frac === Number.NEGATIVE_INFINITY || Number.isNaN(frac)) {
    return frac;
  }
  return frac * Math.pow(2, exp);
}
/**
 * Computes the next power of two that is greater than or equal to v.
 * This implementation more efficient than, but functionally equivalent
 * to Math.pow(2, Math.ceil(Math.log(x)/Math.log(2))).
 * @param v
 * @returns {number}
 */
function nextGreaterSquare(v) {
  // The following expression computes the least power-of-two
  // that is >= v.  There are a number of tricky ways to
  // do this, see https://stackoverflow.com/questions/466204/rounding-up-to-next-power-of-2
  v--;
  v |= v >> 1;
  v |= v >> 2;
  v |= v >> 4;
  v |= v >> 8;
  v |= v >> 16;
  v++;
  return v;
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class MappingError extends Error {}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * ExponentMapping implements exponential mapping functions for
 * scales <=0. For scales > 0 LogarithmMapping should be used.
 */
class ExponentMapping {
  _shift;
  constructor(scale) {
    this._shift = -scale;
  }
  /**
   * Maps positive floating point values to indexes corresponding to scale
   * @param value
   * @returns {number} index for provided value at the current scale
   */
  mapToIndex(value) {
    if (value < MIN_VALUE) {
      return this._minNormalLowerBoundaryIndex();
    }
    const exp = getNormalBase2(value);
    // In case the value is an exact power of two, compute a
    // correction of -1. Note, we are using a custom _rightShift
    // to accommodate a 52-bit argument, which the native bitwise
    // operators do not support
    const correction = this._rightShift(getSignificand(value) - 1, SIGNIFICAND_WIDTH);
    return exp + correction >> this._shift;
  }
  /**
   * Returns the lower bucket boundary for the given index for scale
   *
   * @param index
   * @returns {number}
   */
  lowerBoundary(index) {
    const minIndex = this._minNormalLowerBoundaryIndex();
    if (index < minIndex) {
      throw new MappingError(`underflow: ${index} is < minimum lower boundary: ${minIndex}`);
    }
    const maxIndex = this._maxNormalLowerBoundaryIndex();
    if (index > maxIndex) {
      throw new MappingError(`overflow: ${index} is > maximum lower boundary: ${maxIndex}`);
    }
    return ldexp(1, index << this._shift);
  }
  /**
   * The scale used by this mapping
   * @returns {number}
   */
  get scale() {
    if (this._shift === 0) {
      return 0;
    }
    return -this._shift;
  }
  _minNormalLowerBoundaryIndex() {
    let index = MIN_NORMAL_EXPONENT >> this._shift;
    if (this._shift < 2) {
      index--;
    }
    return index;
  }
  _maxNormalLowerBoundaryIndex() {
    return MAX_NORMAL_EXPONENT >> this._shift;
  }
  _rightShift(value, shift) {
    return Math.floor(value * Math.pow(2, -shift));
  }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * LogarithmMapping implements exponential mapping functions for scale > 0.
 * For scales <= 0 the exponent mapping should be used.
 */
class LogarithmMapping {
  _scale;
  _scaleFactor;
  _inverseFactor;
  constructor(scale) {
    this._scale = scale;
    this._scaleFactor = ldexp(Math.LOG2E, scale);
    this._inverseFactor = ldexp(Math.LN2, -scale);
  }
  /**
   * Maps positive floating point values to indexes corresponding to scale
   * @param value
   * @returns {number} index for provided value at the current scale
   */
  mapToIndex(value) {
    if (value <= MIN_VALUE) {
      return this._minNormalLowerBoundaryIndex() - 1;
    }
    // exact power of two special case
    if (getSignificand(value) === 0) {
      const exp = getNormalBase2(value);
      return (exp << this._scale) - 1;
    }
    // non-power of two cases. use Math.floor to round the scaled logarithm
    const index = Math.floor(Math.log(value) * this._scaleFactor);
    const maxIndex = this._maxNormalLowerBoundaryIndex();
    if (index >= maxIndex) {
      return maxIndex;
    }
    return index;
  }
  /**
   * Returns the lower bucket boundary for the given index for scale
   *
   * @param index
   * @returns {number}
   */
  lowerBoundary(index) {
    const maxIndex = this._maxNormalLowerBoundaryIndex();
    if (index >= maxIndex) {
      if (index === maxIndex) {
        return 2 * Math.exp((index - (1 << this._scale)) / this._scaleFactor);
      }
      throw new MappingError(`overflow: ${index} is > maximum lower boundary: ${maxIndex}`);
    }
    const minIndex = this._minNormalLowerBoundaryIndex();
    if (index <= minIndex) {
      if (index === minIndex) {
        return MIN_VALUE;
      } else if (index === minIndex - 1) {
        return Math.exp((index + (1 << this._scale)) / this._scaleFactor) / 2;
      }
      throw new MappingError(`overflow: ${index} is < minimum lower boundary: ${minIndex}`);
    }
    return Math.exp(index * this._inverseFactor);
  }
  /**
   * The scale used by this mapping
   * @returns {number}
   */
  get scale() {
    return this._scale;
  }
  _minNormalLowerBoundaryIndex() {
    return MIN_NORMAL_EXPONENT << this._scale;
  }
  _maxNormalLowerBoundaryIndex() {
    return (MAX_NORMAL_EXPONENT + 1 << this._scale) - 1;
  }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const MIN_SCALE = -10;
const MAX_SCALE$1 = 20;
const PREBUILT_MAPPINGS = Array.from({
  length: 31
}, (_, i) => {
  if (i > 10) {
    return new LogarithmMapping(i - 10);
  }
  return new ExponentMapping(i - 10);
});
/**
 * getMapping returns an appropriate mapping for the given scale. For scales -10
 * to 0 the underlying type will be ExponentMapping. For scales 1 to 20 the
 * underlying type will be LogarithmMapping.
 * @param scale a number in the range [-10, 20]
 * @returns {Mapping}
 */
function getMapping(scale) {
  if (scale > MAX_SCALE$1 || scale < MIN_SCALE) {
    throw new MappingError(`expected scale >= ${MIN_SCALE} && <= ${MAX_SCALE$1}, got: ${scale}`);
  }
  // mappings are offset by 10. scale -10 is at position 0 and scale 20 is at 30
  return PREBUILT_MAPPINGS[scale + 10];
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// HighLow is a utility class used for computing a common scale for
// two exponential histogram accumulations
class HighLow {
  low;
  high;
  static combine(h1, h2) {
    return new HighLow(Math.min(h1.low, h2.low), Math.max(h1.high, h2.high));
  }
  constructor(low, high) {
    this.low = low;
    this.high = high;
  }
}
const MAX_SCALE = 20;
const DEFAULT_MAX_SIZE = 160;
const MIN_MAX_SIZE = 2;
class ExponentialHistogramAccumulation {
  startTime;
  _maxSize;
  _recordMinMax;
  _sum;
  _count;
  _zeroCount;
  _min;
  _max;
  _positive;
  _negative;
  _mapping;
  constructor(startTime = startTime, _maxSize = DEFAULT_MAX_SIZE, _recordMinMax = true, _sum = 0, _count = 0, _zeroCount = 0, _min = Number.POSITIVE_INFINITY, _max = Number.NEGATIVE_INFINITY, _positive = new Buckets(), _negative = new Buckets(), _mapping = getMapping(MAX_SCALE)) {
    this.startTime = startTime;
    this._maxSize = _maxSize;
    this._recordMinMax = _recordMinMax;
    this._sum = _sum;
    this._count = _count;
    this._zeroCount = _zeroCount;
    this._min = _min;
    this._max = _max;
    this._positive = _positive;
    this._negative = _negative;
    this._mapping = _mapping;
    if (this._maxSize < MIN_MAX_SIZE) {
      api.diag.warn(`Exponential Histogram Max Size set to ${this._maxSize}, \
                changing to the minimum size of: ${MIN_MAX_SIZE}`);
      this._maxSize = MIN_MAX_SIZE;
    }
  }
  /**
   * record updates a histogram with a single count
   * @param {Number} value
   */
  record(value) {
    this.updateByIncrement(value, 1);
  }
  /**
   * Sets the start time for this accumulation
   * @param {HrTime} startTime
   */
  setStartTime(startTime) {
    this.startTime = startTime;
  }
  /**
   * Returns the datapoint representation of this accumulation
   * @param {HrTime} startTime
   */
  toPointValue() {
    return {
      hasMinMax: this._recordMinMax,
      min: this.min,
      max: this.max,
      sum: this.sum,
      positive: {
        offset: this.positive.offset,
        bucketCounts: this.positive.counts()
      },
      negative: {
        offset: this.negative.offset,
        bucketCounts: this.negative.counts()
      },
      count: this.count,
      scale: this.scale,
      zeroCount: this.zeroCount
    };
  }
  /**
   * @returns {Number} The sum of values recorded by this accumulation
   */
  get sum() {
    return this._sum;
  }
  /**
   * @returns {Number} The minimum value recorded by this accumulation
   */
  get min() {
    return this._min;
  }
  /**
   * @returns {Number} The maximum value recorded by this accumulation
   */
  get max() {
    return this._max;
  }
  /**
   * @returns {Number} The count of values recorded by this accumulation
   */
  get count() {
    return this._count;
  }
  /**
   * @returns {Number} The number of 0 values recorded by this accumulation
   */
  get zeroCount() {
    return this._zeroCount;
  }
  /**
   * @returns {Number} The scale used by this accumulation
   */
  get scale() {
    if (this._count === this._zeroCount) {
      // all zeros! scale doesn't matter, use zero
      return 0;
    }
    return this._mapping.scale;
  }
  /**
   * positive holds the positive values
   * @returns {Buckets}
   */
  get positive() {
    return this._positive;
  }
  /**
   * negative holds the negative values by their absolute value
   * @returns {Buckets}
   */
  get negative() {
    return this._negative;
  }
  /**
   * updateByIncr supports updating a histogram with a non-negative
   * increment.
   * @param value
   * @param increment
   */
  updateByIncrement(value, increment) {
    // NaN does not fall into any bucket, is not zero and should not be counted,
    // NaN is never greater than max nor less than min, therefore return as there's nothing for us to do.
    if (Number.isNaN(value)) {
      return;
    }
    if (value > this._max) {
      this._max = value;
    }
    if (value < this._min) {
      this._min = value;
    }
    this._count += increment;
    if (value === 0) {
      this._zeroCount += increment;
      return;
    }
    this._sum += value * increment;
    if (value > 0) {
      this._updateBuckets(this._positive, value, increment);
    } else {
      this._updateBuckets(this._negative, -value, increment);
    }
  }
  /**
   * merge combines data from previous value into self
   * @param {ExponentialHistogramAccumulation} previous
   */
  merge(previous) {
    if (this._count === 0) {
      this._min = previous.min;
      this._max = previous.max;
    } else if (previous.count !== 0) {
      if (previous.min < this.min) {
        this._min = previous.min;
      }
      if (previous.max > this.max) {
        this._max = previous.max;
      }
    }
    this.startTime = previous.startTime;
    this._sum += previous.sum;
    this._count += previous.count;
    this._zeroCount += previous.zeroCount;
    const minScale = this._minScale(previous);
    this._downscale(this.scale - minScale);
    this._mergeBuckets(this.positive, previous, previous.positive, minScale);
    this._mergeBuckets(this.negative, previous, previous.negative, minScale);
  }
  /**
   * diff subtracts other from self
   * @param {ExponentialHistogramAccumulation} other
   */
  diff(other) {
    this._min = Infinity;
    this._max = -Infinity;
    this._sum -= other.sum;
    this._count -= other.count;
    this._zeroCount -= other.zeroCount;
    const minScale = this._minScale(other);
    this._downscale(this.scale - minScale);
    this._diffBuckets(this.positive, other, other.positive, minScale);
    this._diffBuckets(this.negative, other, other.negative, minScale);
  }
  /**
   * clone returns a deep copy of self
   * @returns {ExponentialHistogramAccumulation}
   */
  clone() {
    return new ExponentialHistogramAccumulation(this.startTime, this._maxSize, this._recordMinMax, this._sum, this._count, this._zeroCount, this._min, this._max, this.positive.clone(), this.negative.clone(), this._mapping);
  }
  /**
   * _updateBuckets maps the incoming value to a bucket index for the current
   * scale. If the bucket index is outside of the range of the backing array,
   * it will rescale the backing array and update the mapping for the new scale.
   */
  _updateBuckets(buckets, value, increment) {
    let index = this._mapping.mapToIndex(value);
    // rescale the mapping if needed
    let rescalingNeeded = false;
    let high = 0;
    let low = 0;
    if (buckets.length === 0) {
      buckets.indexStart = index;
      buckets.indexEnd = buckets.indexStart;
      buckets.indexBase = buckets.indexStart;
    } else if (index < buckets.indexStart && buckets.indexEnd - index >= this._maxSize) {
      rescalingNeeded = true;
      low = index;
      high = buckets.indexEnd;
    } else if (index > buckets.indexEnd && index - buckets.indexStart >= this._maxSize) {
      rescalingNeeded = true;
      low = buckets.indexStart;
      high = index;
    }
    // rescale and compute index at new scale
    if (rescalingNeeded) {
      const change = this._changeScale(high, low);
      this._downscale(change);
      index = this._mapping.mapToIndex(value);
    }
    this._incrementIndexBy(buckets, index, increment);
  }
  /**
   * _incrementIndexBy increments the count of the bucket specified by `index`.
   * If the index is outside of the range [buckets.indexStart, buckets.indexEnd]
   * the boundaries of the backing array will be adjusted and more buckets will
   * be added if needed.
   */
  _incrementIndexBy(buckets, index, increment) {
    if (increment === 0) {
      // nothing to do for a zero increment, can happen during a merge operation
      return;
    }
    if (buckets.length === 0) {
      buckets.indexStart = buckets.indexEnd = buckets.indexBase = index;
    }
    if (index < buckets.indexStart) {
      const span = buckets.indexEnd - index;
      if (span >= buckets.backing.length) {
        this._grow(buckets, span + 1);
      }
      buckets.indexStart = index;
    } else if (index > buckets.indexEnd) {
      const span = index - buckets.indexStart;
      if (span >= buckets.backing.length) {
        this._grow(buckets, span + 1);
      }
      buckets.indexEnd = index;
    }
    let bucketIndex = index - buckets.indexBase;
    if (bucketIndex < 0) {
      bucketIndex += buckets.backing.length;
    }
    buckets.incrementBucket(bucketIndex, increment);
  }
  /**
   * grow resizes the backing array by doubling in size up to maxSize.
   * This extends the array with a bunch of zeros and copies the
   * existing counts to the same position.
   */
  _grow(buckets, needed) {
    const size = buckets.backing.length;
    const bias = buckets.indexBase - buckets.indexStart;
    const oldPositiveLimit = size - bias;
    let newSize = nextGreaterSquare(needed);
    if (newSize > this._maxSize) {
      newSize = this._maxSize;
    }
    const newPositiveLimit = newSize - bias;
    buckets.backing.growTo(newSize, oldPositiveLimit, newPositiveLimit);
  }
  /**
   * _changeScale computes how much downscaling is needed by shifting the
   * high and low values until they are separated by no more than size.
   */
  _changeScale(high, low) {
    let change = 0;
    while (high - low >= this._maxSize) {
      high >>= 1;
      low >>= 1;
      change++;
    }
    return change;
  }
  /**
   * _downscale subtracts `change` from the current mapping scale.
   */
  _downscale(change) {
    if (change === 0) {
      return;
    }
    if (change < 0) {
      // Note: this should be impossible. If we get here it's because
      // there is a bug in the implementation.
      throw new Error(`impossible change of scale: ${this.scale}`);
    }
    const newScale = this._mapping.scale - change;
    this._positive.downscale(change);
    this._negative.downscale(change);
    this._mapping = getMapping(newScale);
  }
  /**
   * _minScale is used by diff and merge to compute an ideal combined scale
   */
  _minScale(other) {
    const minScale = Math.min(this.scale, other.scale);
    const highLowPos = HighLow.combine(this._highLowAtScale(this.positive, this.scale, minScale), this._highLowAtScale(other.positive, other.scale, minScale));
    const highLowNeg = HighLow.combine(this._highLowAtScale(this.negative, this.scale, minScale), this._highLowAtScale(other.negative, other.scale, minScale));
    return Math.min(minScale - this._changeScale(highLowPos.high, highLowPos.low), minScale - this._changeScale(highLowNeg.high, highLowNeg.low));
  }
  /**
   * _highLowAtScale is used by diff and merge to compute an ideal combined scale.
   */
  _highLowAtScale(buckets, currentScale, newScale) {
    if (buckets.length === 0) {
      return new HighLow(0, -1);
    }
    const shift = currentScale - newScale;
    return new HighLow(buckets.indexStart >> shift, buckets.indexEnd >> shift);
  }
  /**
   * _mergeBuckets translates index values from another histogram and
   * adds the values into the corresponding buckets of this histogram.
   */
  _mergeBuckets(ours, other, theirs, scale) {
    const theirOffset = theirs.offset;
    const theirChange = other.scale - scale;
    for (let i = 0; i < theirs.length; i++) {
      this._incrementIndexBy(ours, theirOffset + i >> theirChange, theirs.at(i));
    }
  }
  /**
   * _diffBuckets translates index values from another histogram and
   * subtracts the values in the corresponding buckets of this histogram.
   */
  _diffBuckets(ours, other, theirs, scale) {
    const theirOffset = theirs.offset;
    const theirChange = other.scale - scale;
    for (let i = 0; i < theirs.length; i++) {
      const ourIndex = theirOffset + i >> theirChange;
      let bucketIndex = ourIndex - ours.indexBase;
      if (bucketIndex < 0) {
        bucketIndex += ours.backing.length;
      }
      ours.decrementBucket(bucketIndex, theirs.at(i));
    }
    ours.trim();
  }
}
/**
 * Aggregator for ExponentialHistogramAccumulations
 */
class ExponentialHistogramAggregator {
  _maxSize;
  _recordMinMax;
  kind = AggregatorKind.EXPONENTIAL_HISTOGRAM;
  /**
   * @param _maxSize Maximum number of buckets for each of the positive
   *    and negative ranges, exclusive of the zero-bucket.
   * @param _recordMinMax If set to true, min and max will be recorded.
   *    Otherwise, min and max will not be recorded.
   */
  constructor(_maxSize, _recordMinMax) {
    this._maxSize = _maxSize;
    this._recordMinMax = _recordMinMax;
  }
  createAccumulation(startTime) {
    return new ExponentialHistogramAccumulation(startTime, this._maxSize, this._recordMinMax);
  }
  /**
   * Return the result of the merge of two exponential histogram accumulations.
   */
  merge(previous, delta) {
    const result = delta.clone();
    result.merge(previous);
    return result;
  }
  /**
   * Returns a new DELTA aggregation by comparing two cumulative measurements.
   */
  diff(previous, current) {
    const result = current.clone();
    result.diff(previous);
    return result;
  }
  toMetricData(descriptor, aggregationTemporality, accumulationByAttributes, endTime) {
    return {
      descriptor,
      aggregationTemporality,
      dataPointType: DataPointType.EXPONENTIAL_HISTOGRAM,
      dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => {
        const pointValue = accumulation.toPointValue();
        // determine if instrument allows negative values.
        const allowsNegativeValues = descriptor.type === InstrumentType.GAUGE || descriptor.type === InstrumentType.UP_DOWN_COUNTER || descriptor.type === InstrumentType.OBSERVABLE_GAUGE || descriptor.type === InstrumentType.OBSERVABLE_UP_DOWN_COUNTER;
        return {
          attributes,
          startTime: accumulation.startTime,
          endTime,
          value: {
            min: pointValue.hasMinMax ? pointValue.min : undefined,
            max: pointValue.hasMinMax ? pointValue.max : undefined,
            sum: !allowsNegativeValues ? pointValue.sum : undefined,
            positive: {
              offset: pointValue.positive.offset,
              bucketCounts: pointValue.positive.bucketCounts
            },
            negative: {
              offset: pointValue.negative.offset,
              bucketCounts: pointValue.negative.bucketCounts
            },
            count: pointValue.count,
            scale: pointValue.scale,
            zeroCount: pointValue.zeroCount
          }
        };
      })
    };
  }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class LastValueAccumulation {
  startTime;
  _current;
  sampleTime;
  constructor(startTime, _current = 0, sampleTime = [0, 0]) {
    this.startTime = startTime;
    this._current = _current;
    this.sampleTime = sampleTime;
  }
  record(value) {
    this._current = value;
    this.sampleTime = core.millisToHrTime(Date.now());
  }
  setStartTime(startTime) {
    this.startTime = startTime;
  }
  toPointValue() {
    return this._current;
  }
}
/** Basic aggregator which calculates a LastValue from individual measurements. */
class LastValueAggregator {
  kind = AggregatorKind.LAST_VALUE;
  createAccumulation(startTime) {
    return new LastValueAccumulation(startTime);
  }
  /**
   * Returns the result of the merge of the given accumulations.
   *
   * Return the newly captured (delta) accumulation for LastValueAggregator.
   */
  merge(previous, delta) {
    // nanoseconds may lose precisions.
    const latestAccumulation = core.hrTimeToMicroseconds(delta.sampleTime) >= core.hrTimeToMicroseconds(previous.sampleTime) ? delta : previous;
    return new LastValueAccumulation(previous.startTime, latestAccumulation.toPointValue(), latestAccumulation.sampleTime);
  }
  /**
   * Returns a new DELTA aggregation by comparing two cumulative measurements.
   *
   * A delta aggregation is not meaningful to LastValueAggregator, just return
   * the newly captured (delta) accumulation for LastValueAggregator.
   */
  diff(previous, current) {
    // nanoseconds may lose precisions.
    const latestAccumulation = core.hrTimeToMicroseconds(current.sampleTime) >= core.hrTimeToMicroseconds(previous.sampleTime) ? current : previous;
    return new LastValueAccumulation(current.startTime, latestAccumulation.toPointValue(), latestAccumulation.sampleTime);
  }
  toMetricData(descriptor, aggregationTemporality, accumulationByAttributes, endTime) {
    return {
      descriptor,
      aggregationTemporality,
      dataPointType: DataPointType.GAUGE,
      dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => {
        return {
          attributes,
          startTime: accumulation.startTime,
          endTime,
          value: accumulation.toPointValue()
        };
      })
    };
  }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class SumAccumulation {
  startTime;
  monotonic;
  _current;
  reset;
  constructor(startTime, monotonic, _current = 0, reset = false) {
    this.startTime = startTime;
    this.monotonic = monotonic;
    this._current = _current;
    this.reset = reset;
  }
  record(value) {
    if (this.monotonic && value < 0) {
      return;
    }
    this._current += value;
  }
  setStartTime(startTime) {
    this.startTime = startTime;
  }
  toPointValue() {
    return this._current;
  }
}
/** Basic aggregator which calculates a Sum from individual measurements. */
class SumAggregator {
  monotonic;
  kind = AggregatorKind.SUM;
  constructor(monotonic) {
    this.monotonic = monotonic;
  }
  createAccumulation(startTime) {
    return new SumAccumulation(startTime, this.monotonic);
  }
  /**
   * Returns the result of the merge of the given accumulations.
   */
  merge(previous, delta) {
    const prevPv = previous.toPointValue();
    const deltaPv = delta.toPointValue();
    if (delta.reset) {
      return new SumAccumulation(delta.startTime, this.monotonic, deltaPv, delta.reset);
    }
    return new SumAccumulation(previous.startTime, this.monotonic, prevPv + deltaPv);
  }
  /**
   * Returns a new DELTA aggregation by comparing two cumulative measurements.
   */
  diff(previous, current) {
    const prevPv = previous.toPointValue();
    const currPv = current.toPointValue();
    /**
     * If the SumAggregator is a monotonic one and the previous point value is
     * greater than the current one, a reset is deemed to be happened.
     * Return the current point value to prevent the value from been reset.
     */
    if (this.monotonic && prevPv > currPv) {
      return new SumAccumulation(current.startTime, this.monotonic, currPv, true);
    }
    return new SumAccumulation(current.startTime, this.monotonic, currPv - prevPv);
  }
  toMetricData(descriptor, aggregationTemporality, accumulationByAttributes, endTime) {
    return {
      descriptor,
      aggregationTemporality,
      dataPointType: DataPointType.SUM,
      dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => {
        return {
          attributes,
          startTime: accumulation.startTime,
          endTime,
          value: accumulation.toPointValue()
        };
      }),
      isMonotonic: this.monotonic
    };
  }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The default drop aggregation.
 */
class DropAggregation {
  static DEFAULT_INSTANCE = new DropAggregator();
  createAggregator(_instrument) {
    return DropAggregation.DEFAULT_INSTANCE;
  }
}
/**
 * The default sum aggregation.
 */
class SumAggregation {
  static MONOTONIC_INSTANCE = new SumAggregator(true);
  static NON_MONOTONIC_INSTANCE = new SumAggregator(false);
  createAggregator(instrument) {
    switch (instrument.type) {
      case InstrumentType.COUNTER:
      case InstrumentType.OBSERVABLE_COUNTER:
      case InstrumentType.HISTOGRAM:
        {
          return SumAggregation.MONOTONIC_INSTANCE;
        }
      default:
        {
          return SumAggregation.NON_MONOTONIC_INSTANCE;
        }
    }
  }
}
/**
 * The default last value aggregation.
 */
class LastValueAggregation {
  static DEFAULT_INSTANCE = new LastValueAggregator();
  createAggregator(_instrument) {
    return LastValueAggregation.DEFAULT_INSTANCE;
  }
}
/**
 * The default histogram aggregation.

 */
class HistogramAggregation {
  static DEFAULT_INSTANCE = new HistogramAggregator([0, 5, 10, 25, 50, 75, 100, 250, 500, 750, 1000, 2500, 5000, 7500, 10000], true);
  createAggregator(_instrument) {
    return HistogramAggregation.DEFAULT_INSTANCE;
  }
}
/**
 * The explicit bucket histogram aggregation.
 */
class ExplicitBucketHistogramAggregation {
  _recordMinMax;
  _boundaries;
  /**
   * @param boundaries the bucket boundaries of the histogram aggregation
   * @param _recordMinMax If set to true, min and max will be recorded. Otherwise, min and max will not be recorded.
   */
  constructor(boundaries, _recordMinMax = true) {
    this._recordMinMax = _recordMinMax;
    if (boundaries == null) {
      throw new Error('ExplicitBucketHistogramAggregation should be created with explicit boundaries, if a single bucket histogram is required, please pass an empty array');
    }
    // Copy the boundaries array for modification.
    boundaries = boundaries.concat();
    // We need to an ordered set to be able to correctly compute count for each
    // boundary since we'll iterate on each in order.
    boundaries = boundaries.sort((a, b) => a - b);
    // Remove all Infinity from the boundaries.
    const minusInfinityIndex = boundaries.lastIndexOf(-Infinity);
    let infinityIndex = boundaries.indexOf(Infinity);
    if (infinityIndex === -1) {
      infinityIndex = undefined;
    }
    this._boundaries = boundaries.slice(minusInfinityIndex + 1, infinityIndex);
  }
  createAggregator(_instrument) {
    return new HistogramAggregator(this._boundaries, this._recordMinMax);
  }
}
class ExponentialHistogramAggregation {
  _maxSize;
  _recordMinMax;
  constructor(_maxSize = 160, _recordMinMax = true) {
    this._maxSize = _maxSize;
    this._recordMinMax = _recordMinMax;
  }
  createAggregator(_instrument) {
    return new ExponentialHistogramAggregator(this._maxSize, this._recordMinMax);
  }
}
/**
 * The default aggregation.
 */
class DefaultAggregation {
  _resolve(instrument) {
    // cast to unknown to disable complaints on the (unreachable) fallback.
    switch (instrument.type) {
      case InstrumentType.COUNTER:
      case InstrumentType.UP_DOWN_COUNTER:
      case InstrumentType.OBSERVABLE_COUNTER:
      case InstrumentType.OBSERVABLE_UP_DOWN_COUNTER:
        {
          return SUM_AGGREGATION;
        }
      case InstrumentType.GAUGE:
      case InstrumentType.OBSERVABLE_GAUGE:
        {
          return LAST_VALUE_AGGREGATION;
        }
      case InstrumentType.HISTOGRAM:
        {
          if (instrument.advice.explicitBucketBoundaries) {
            return new ExplicitBucketHistogramAggregation(instrument.advice.explicitBucketBoundaries);
          }
          return HISTOGRAM_AGGREGATION;
        }
    }
    api__namespace.diag.warn(`Unable to recognize instrument type: ${instrument.type}`);
    return DROP_AGGREGATION;
  }
  createAggregator(instrument) {
    return this._resolve(instrument).createAggregator(instrument);
  }
}
const DROP_AGGREGATION = new DropAggregation();
const SUM_AGGREGATION = new SumAggregation();
const LAST_VALUE_AGGREGATION = new LastValueAggregation();
const HISTOGRAM_AGGREGATION = new HistogramAggregation();
const DEFAULT_AGGREGATION = new DefaultAggregation();

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var AggregationType;
(function (AggregationType) {
  AggregationType[AggregationType["DEFAULT"] = 0] = "DEFAULT";
  AggregationType[AggregationType["DROP"] = 1] = "DROP";
  AggregationType[AggregationType["SUM"] = 2] = "SUM";
  AggregationType[AggregationType["LAST_VALUE"] = 3] = "LAST_VALUE";
  AggregationType[AggregationType["EXPLICIT_BUCKET_HISTOGRAM"] = 4] = "EXPLICIT_BUCKET_HISTOGRAM";
  AggregationType[AggregationType["EXPONENTIAL_HISTOGRAM"] = 5] = "EXPONENTIAL_HISTOGRAM";
})(AggregationType || (AggregationType = {}));
function toAggregation(option) {
  switch (option.type) {
    case AggregationType.DEFAULT:
      return DEFAULT_AGGREGATION;
    case AggregationType.DROP:
      return DROP_AGGREGATION;
    case AggregationType.SUM:
      return SUM_AGGREGATION;
    case AggregationType.LAST_VALUE:
      return LAST_VALUE_AGGREGATION;
    case AggregationType.EXPONENTIAL_HISTOGRAM:
      {
        const expOption = option;
        return new ExponentialHistogramAggregation(expOption.options?.maxSize, expOption.options?.recordMinMax);
      }
    case AggregationType.EXPLICIT_BUCKET_HISTOGRAM:
      {
        const expOption = option;
        if (expOption.options == null) {
          return HISTOGRAM_AGGREGATION;
        } else {
          return new ExplicitBucketHistogramAggregation(expOption.options?.boundaries, expOption.options?.recordMinMax);
        }
      }
    default:
      throw new Error('Unsupported Aggregation');
  }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DEFAULT_AGGREGATION_SELECTOR = _instrumentType => {
  return {
    type: AggregationType.DEFAULT
  };
};
const DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR = _instrumentType => AggregationTemporality.CUMULATIVE;

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A registered reader of metrics that, when linked to a {@link MetricProducer}, offers global
 * control over metrics.
 */
class MetricReader {
  // Tracks the shutdown state.
  // TODO: use BindOncePromise here once a new version of @opentelemetry/core is available.
  _shutdown = false;
  // Additional MetricProducers which will be combined with the SDK's output
  _metricProducers;
  // MetricProducer used by this instance which produces metrics from the SDK
  _sdkMetricProducer;
  _aggregationTemporalitySelector;
  _aggregationSelector;
  _cardinalitySelector;
  constructor(options) {
    this._aggregationSelector = options?.aggregationSelector ?? DEFAULT_AGGREGATION_SELECTOR;
    this._aggregationTemporalitySelector = options?.aggregationTemporalitySelector ?? DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR;
    this._metricProducers = options?.metricProducers ?? [];
    this._cardinalitySelector = options?.cardinalitySelector;
  }
  setMetricProducer(metricProducer) {
    if (this._sdkMetricProducer) {
      throw new Error('MetricReader can not be bound to a MeterProvider again.');
    }
    this._sdkMetricProducer = metricProducer;
    this.onInitialized();
  }
  selectAggregation(instrumentType) {
    return this._aggregationSelector(instrumentType);
  }
  selectAggregationTemporality(instrumentType) {
    return this._aggregationTemporalitySelector(instrumentType);
  }
  selectCardinalityLimit(instrumentType) {
    return this._cardinalitySelector ? this._cardinalitySelector(instrumentType) : 2000; // default value if no selector is provided
  }
  /**
   * Handle once the SDK has initialized this {@link MetricReader}
   * Overriding this method is optional.
   */
  onInitialized() {
    // Default implementation is empty.
  }
  async collect(options) {
    if (this._sdkMetricProducer === undefined) {
      throw new Error('MetricReader is not bound to a MetricProducer');
    }
    // Subsequent invocations to collect are not allowed. SDKs SHOULD return some failure for these calls.
    if (this._shutdown) {
      throw new Error('MetricReader is shutdown');
    }
    const [sdkCollectionResults, ...additionalCollectionResults] = await Promise.all([this._sdkMetricProducer.collect({
      timeoutMillis: options?.timeoutMillis
    }), ...this._metricProducers.map(producer => producer.collect({
      timeoutMillis: options?.timeoutMillis
    }))]);
    // Merge the results, keeping the SDK's Resource
    const errors = sdkCollectionResults.errors.concat(FlatMap(additionalCollectionResults, result => result.errors));
    const resource = sdkCollectionResults.resourceMetrics.resource;
    const scopeMetrics = sdkCollectionResults.resourceMetrics.scopeMetrics.concat(FlatMap(additionalCollectionResults, result => result.resourceMetrics.scopeMetrics));
    return {
      resourceMetrics: {
        resource,
        scopeMetrics
      },
      errors
    };
  }
  async shutdown(options) {
    // Do not call shutdown again if it has already been called.
    if (this._shutdown) {
      api__namespace.diag.error('Cannot call shutdown twice.');
      return;
    }
    // No timeout if timeoutMillis is undefined or null.
    if (options?.timeoutMillis == null) {
      await this.onShutdown();
    } else {
      await callWithTimeout(this.onShutdown(), options.timeoutMillis);
    }
    this._shutdown = true;
  }
  async forceFlush(options) {
    if (this._shutdown) {
      api__namespace.diag.warn('Cannot forceFlush on already shutdown MetricReader.');
      return;
    }
    // No timeout if timeoutMillis is undefined or null.
    if (options?.timeoutMillis == null) {
      await this.onForceFlush();
      return;
    }
    await callWithTimeout(this.onForceFlush(), options.timeoutMillis);
  }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * {@link MetricReader} which collects metrics based on a user-configurable time interval, and passes the metrics to
 * the configured {@link PushMetricExporter}
 */
class PeriodicExportingMetricReader extends MetricReader {
  _interval;
  _exporter;
  _exportInterval;
  _exportTimeout;
  constructor(options) {
    super({
      aggregationSelector: options.exporter.selectAggregation?.bind(options.exporter),
      aggregationTemporalitySelector: options.exporter.selectAggregationTemporality?.bind(options.exporter),
      metricProducers: options.metricProducers
    });
    if (options.exportIntervalMillis !== undefined && options.exportIntervalMillis <= 0) {
      throw Error('exportIntervalMillis must be greater than 0');
    }
    if (options.exportTimeoutMillis !== undefined && options.exportTimeoutMillis <= 0) {
      throw Error('exportTimeoutMillis must be greater than 0');
    }
    if (options.exportTimeoutMillis !== undefined && options.exportIntervalMillis !== undefined && options.exportIntervalMillis < options.exportTimeoutMillis) {
      throw Error('exportIntervalMillis must be greater than or equal to exportTimeoutMillis');
    }
    this._exportInterval = options.exportIntervalMillis ?? 60000;
    this._exportTimeout = options.exportTimeoutMillis ?? 30000;
    this._exporter = options.exporter;
  }
  async _runOnce() {
    try {
      await callWithTimeout(this._doRun(), this._exportTimeout);
    } catch (err) {
      if (err instanceof TimeoutError) {
        api__namespace.diag.error('Export took longer than %s milliseconds and timed out.', this._exportTimeout);
        return;
      }
      core.globalErrorHandler(err);
    }
  }
  async _doRun() {
    const {
      resourceMetrics,
      errors
    } = await this.collect({
      timeoutMillis: this._exportTimeout
    });
    if (errors.length > 0) {
      api__namespace.diag.error('PeriodicExportingMetricReader: metrics collection errors', ...errors);
    }
    if (resourceMetrics.resource.asyncAttributesPending) {
      try {
        await resourceMetrics.resource.waitForAsyncAttributes?.();
      } catch (e) {
        api__namespace.diag.debug('Error while resolving async portion of resource: ', e);
        core.globalErrorHandler(e);
      }
    }
    if (resourceMetrics.scopeMetrics.length === 0) {
      return;
    }
    const result = await core.internal._export(this._exporter, resourceMetrics);
    if (result.code !== core.ExportResultCode.SUCCESS) {
      throw new Error(`PeriodicExportingMetricReader: metrics export failed (error ${result.error})`);
    }
  }
  onInitialized() {
    // start running the interval as soon as this reader is initialized and keep handle for shutdown.
    this._interval = setInterval(() => {
      // this._runOnce never rejects. Using void operator to suppress @typescript-eslint/no-floating-promises.
      void this._runOnce();
    }, this._exportInterval);
    core.unrefTimer(this._interval);
  }
  async onForceFlush() {
    await this._runOnce();
    await this._exporter.forceFlush();
  }
  async onShutdown() {
    if (this._interval) {
      clearInterval(this._interval);
    }
    await this.onForceFlush();
    await this._exporter.shutdown();
  }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This is an implementation of {@link PushMetricExporter} that prints metrics to the
 * console. This class can be used for diagnostic purposes.
 *
 * NOTE: This {@link PushMetricExporter} is intended for diagnostics use only, output rendered to the console may change at any time.
 */
/* eslint-disable no-console */
class ConsoleMetricExporter {
  _shutdown = false;
  _temporalitySelector;
  constructor(options) {
    this._temporalitySelector = options?.temporalitySelector ?? DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR;
  }
  export(metrics, resultCallback) {
    if (this._shutdown) {
      // If the exporter is shutting down, by spec, we need to return FAILED as export result
      setImmediate(resultCallback, {
        code: core.ExportResultCode.FAILED
      });
      return;
    }
    return ConsoleMetricExporter._sendMetrics(metrics, resultCallback);
  }
  forceFlush() {
    return Promise.resolve();
  }
  selectAggregationTemporality(_instrumentType) {
    return this._temporalitySelector(_instrumentType);
  }
  shutdown() {
    this._shutdown = true;
    return Promise.resolve();
  }
  static _sendMetrics(metrics, done) {
    for (const scopeMetrics of metrics.scopeMetrics) {
      for (const metric of scopeMetrics.metrics) {
        console.dir({
          descriptor: metric.descriptor,
          dataPointType: metric.dataPointType,
          dataPoints: metric.dataPoints
        }, {
          depth: null
        });
      }
    }
    done({
      code: core.ExportResultCode.SUCCESS
    });
  }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ViewRegistry {
  _registeredViews = [];
  addView(view) {
    this._registeredViews.push(view);
  }
  findViews(instrument, meter) {
    const views = this._registeredViews.filter(registeredView => {
      return this._matchInstrument(registeredView.instrumentSelector, instrument) && this._matchMeter(registeredView.meterSelector, meter);
    });
    return views;
  }
  _matchInstrument(selector, instrument) {
    return (selector.getType() === undefined || instrument.type === selector.getType()) && selector.getNameFilter().match(instrument.name) && selector.getUnitFilter().match(instrument.unit);
  }
  _matchMeter(selector, meter) {
    return selector.getNameFilter().match(meter.name) && (meter.version === undefined || selector.getVersionFilter().match(meter.version)) && (meter.schemaUrl === undefined || selector.getSchemaUrlFilter().match(meter.schemaUrl));
  }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function createInstrumentDescriptor(name, type, options) {
  if (!isValidName(name)) {
    api.diag.warn(`Invalid metric name: "${name}". The metric name should be a ASCII string with a length no greater than 255 characters.`);
  }
  return {
    name,
    type,
    description: options?.description ?? '',
    unit: options?.unit ?? '',
    valueType: options?.valueType ?? api.ValueType.DOUBLE,
    advice: options?.advice ?? {}
  };
}
function createInstrumentDescriptorWithView(view, instrument) {
  return {
    name: view.name ?? instrument.name,
    description: view.description ?? instrument.description,
    type: instrument.type,
    unit: instrument.unit,
    valueType: instrument.valueType,
    advice: instrument.advice
  };
}
function isDescriptorCompatibleWith(descriptor, otherDescriptor) {
  // Names are case-insensitive strings.
  return equalsCaseInsensitive(descriptor.name, otherDescriptor.name) && descriptor.unit === otherDescriptor.unit && descriptor.type === otherDescriptor.type && descriptor.valueType === otherDescriptor.valueType;
}
// ASCII string with a length no greater than 255 characters.
// NB: the first character counted separately from the rest.
const NAME_REGEXP = /^[a-z][a-z0-9_.\-/]{0,254}$/i;
function isValidName(name) {
  return name.match(NAME_REGEXP) != null;
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class SyncInstrument {
  _writableMetricStorage;
  _descriptor;
  constructor(_writableMetricStorage, _descriptor) {
    this._writableMetricStorage = _writableMetricStorage;
    this._descriptor = _descriptor;
  }
  _record(value, attributes = {}, context = api.context.active()) {
    if (typeof value !== 'number') {
      api.diag.warn(`non-number value provided to metric ${this._descriptor.name}: ${value}`);
      return;
    }
    if (this._descriptor.valueType === api.ValueType.INT && !Number.isInteger(value)) {
      api.diag.warn(`INT value type cannot accept a floating-point value for ${this._descriptor.name}, ignoring the fractional digits.`);
      value = Math.trunc(value);
      // ignore non-finite values.
      if (!Number.isInteger(value)) {
        return;
      }
    }
    this._writableMetricStorage.record(value, attributes, context, core.millisToHrTime(Date.now()));
  }
}
/**
 * The class implements {@link UpDownCounter} interface.
 */
class UpDownCounterInstrument extends SyncInstrument {
  /**
   * Increment value of counter by the input. Inputs may be negative.
   */
  add(value, attributes, ctx) {
    this._record(value, attributes, ctx);
  }
}
/**
 * The class implements {@link Counter} interface.
 */
class CounterInstrument extends SyncInstrument {
  /**
   * Increment value of counter by the input. Inputs may not be negative.
   */
  add(value, attributes, ctx) {
    if (value < 0) {
      api.diag.warn(`negative value provided to counter ${this._descriptor.name}: ${value}`);
      return;
    }
    this._record(value, attributes, ctx);
  }
}
/**
 * The class implements {@link Gauge} interface.
 */
class GaugeInstrument extends SyncInstrument {
  /**
   * Records a measurement.
   */
  record(value, attributes, ctx) {
    this._record(value, attributes, ctx);
  }
}
/**
 * The class implements {@link Histogram} interface.
 */
class HistogramInstrument extends SyncInstrument {
  /**
   * Records a measurement. Value of the measurement must not be negative.
   */
  record(value, attributes, ctx) {
    if (value < 0) {
      api.diag.warn(`negative value provided to histogram ${this._descriptor.name}: ${value}`);
      return;
    }
    this._record(value, attributes, ctx);
  }
}
class ObservableInstrument {
  _observableRegistry;
  /** @internal */
  _metricStorages;
  /** @internal */
  _descriptor;
  constructor(descriptor, metricStorages, _observableRegistry) {
    this._observableRegistry = _observableRegistry;
    this._descriptor = descriptor;
    this._metricStorages = metricStorages;
  }
  /**
   * @see {Observable.addCallback}
   */
  addCallback(callback) {
    this._observableRegistry.addCallback(callback, this);
  }
  /**
   * @see {Observable.removeCallback}
   */
  removeCallback(callback) {
    this._observableRegistry.removeCallback(callback, this);
  }
}
class ObservableCounterInstrument extends ObservableInstrument {}
class ObservableGaugeInstrument extends ObservableInstrument {}
class ObservableUpDownCounterInstrument extends ObservableInstrument {}
function isObservableInstrument(it) {
  return it instanceof ObservableInstrument;
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This class implements the {@link IMeter} interface.
 */
class Meter {
  _meterSharedState;
  constructor(_meterSharedState) {
    this._meterSharedState = _meterSharedState;
  }
  /**
   * Create a {@link Gauge} instrument.
   */
  createGauge(name, options) {
    const descriptor = createInstrumentDescriptor(name, InstrumentType.GAUGE, options);
    const storage = this._meterSharedState.registerMetricStorage(descriptor);
    return new GaugeInstrument(storage, descriptor);
  }
  /**
   * Create a {@link Histogram} instrument.
   */
  createHistogram(name, options) {
    const descriptor = createInstrumentDescriptor(name, InstrumentType.HISTOGRAM, options);
    const storage = this._meterSharedState.registerMetricStorage(descriptor);
    return new HistogramInstrument(storage, descriptor);
  }
  /**
   * Create a {@link Counter} instrument.
   */
  createCounter(name, options) {
    const descriptor = createInstrumentDescriptor(name, InstrumentType.COUNTER, options);
    const storage = this._meterSharedState.registerMetricStorage(descriptor);
    return new CounterInstrument(storage, descriptor);
  }
  /**
   * Create a {@link UpDownCounter} instrument.
   */
  createUpDownCounter(name, options) {
    const descriptor = createInstrumentDescriptor(name, InstrumentType.UP_DOWN_COUNTER, options);
    const storage = this._meterSharedState.registerMetricStorage(descriptor);
    return new UpDownCounterInstrument(storage, descriptor);
  }
  /**
   * Create a {@link ObservableGauge} instrument.
   */
  createObservableGauge(name, options) {
    const descriptor = createInstrumentDescriptor(name, InstrumentType.OBSERVABLE_GAUGE, options);
    const storages = this._meterSharedState.registerAsyncMetricStorage(descriptor);
    return new ObservableGaugeInstrument(descriptor, storages, this._meterSharedState.observableRegistry);
  }
  /**
   * Create a {@link ObservableCounter} instrument.
   */
  createObservableCounter(name, options) {
    const descriptor = createInstrumentDescriptor(name, InstrumentType.OBSERVABLE_COUNTER, options);
    const storages = this._meterSharedState.registerAsyncMetricStorage(descriptor);
    return new ObservableCounterInstrument(descriptor, storages, this._meterSharedState.observableRegistry);
  }
  /**
   * Create a {@link ObservableUpDownCounter} instrument.
   */
  createObservableUpDownCounter(name, options) {
    const descriptor = createInstrumentDescriptor(name, InstrumentType.OBSERVABLE_UP_DOWN_COUNTER, options);
    const storages = this._meterSharedState.registerAsyncMetricStorage(descriptor);
    return new ObservableUpDownCounterInstrument(descriptor, storages, this._meterSharedState.observableRegistry);
  }
  /**
   * @see {@link Meter.addBatchObservableCallback}
   */
  addBatchObservableCallback(callback, observables) {
    this._meterSharedState.observableRegistry.addBatchCallback(callback, observables);
  }
  /**
   * @see {@link Meter.removeBatchObservableCallback}
   */
  removeBatchObservableCallback(callback, observables) {
    this._meterSharedState.observableRegistry.removeBatchCallback(callback, observables);
  }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Internal interface.
 *
 * Represents a storage from which we can collect metrics.
 */
class MetricStorage {
  _instrumentDescriptor;
  constructor(_instrumentDescriptor) {
    this._instrumentDescriptor = _instrumentDescriptor;
  }
  getInstrumentDescriptor() {
    return this._instrumentDescriptor;
  }
  updateDescription(description) {
    this._instrumentDescriptor = createInstrumentDescriptor(this._instrumentDescriptor.name, this._instrumentDescriptor.type, {
      description: description,
      valueType: this._instrumentDescriptor.valueType,
      unit: this._instrumentDescriptor.unit,
      advice: this._instrumentDescriptor.advice
    });
  }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class HashMap {
  _hash;
  _valueMap = new Map();
  _keyMap = new Map();
  constructor(_hash) {
    this._hash = _hash;
  }
  get(key, hashCode) {
    hashCode ??= this._hash(key);
    return this._valueMap.get(hashCode);
  }
  getOrDefault(key, defaultFactory) {
    const hash = this._hash(key);
    if (this._valueMap.has(hash)) {
      return this._valueMap.get(hash);
    }
    const val = defaultFactory();
    if (!this._keyMap.has(hash)) {
      this._keyMap.set(hash, key);
    }
    this._valueMap.set(hash, val);
    return val;
  }
  set(key, value, hashCode) {
    hashCode ??= this._hash(key);
    if (!this._keyMap.has(hashCode)) {
      this._keyMap.set(hashCode, key);
    }
    this._valueMap.set(hashCode, value);
  }
  has(key, hashCode) {
    hashCode ??= this._hash(key);
    return this._valueMap.has(hashCode);
  }
  *keys() {
    const keyIterator = this._keyMap.entries();
    let next = keyIterator.next();
    while (next.done !== true) {
      yield [next.value[1], next.value[0]];
      next = keyIterator.next();
    }
  }
  *entries() {
    const valueIterator = this._valueMap.entries();
    let next = valueIterator.next();
    while (next.done !== true) {
      // next.value[0] here can not be undefined
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      yield [this._keyMap.get(next.value[0]), next.value[1], next.value[0]];
      next = valueIterator.next();
    }
  }
  get size() {
    return this._valueMap.size;
  }
}
class AttributeHashMap extends HashMap {
  constructor() {
    super(hashAttributes);
  }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Internal interface.
 *
 * Allows synchronous collection of metrics. This processor should allow
 * allocation of new aggregation cells for metrics and convert cumulative
 * recording to delta data points.
 */
class DeltaMetricProcessor {
  _aggregator;
  _activeCollectionStorage = new AttributeHashMap();
  // TODO: find a reasonable mean to clean the memo;
  // https://github.com/open-telemetry/opentelemetry-specification/pull/2208
  _cumulativeMemoStorage = new AttributeHashMap();
  _cardinalityLimit;
  _overflowAttributes = {
    'otel.metric.overflow': true
  };
  _overflowHashCode;
  constructor(_aggregator, aggregationCardinalityLimit) {
    this._aggregator = _aggregator;
    this._cardinalityLimit = (aggregationCardinalityLimit ?? 2000) - 1;
    this._overflowHashCode = hashAttributes(this._overflowAttributes);
  }
  record(value, attributes, _context, collectionTime) {
    let accumulation = this._activeCollectionStorage.get(attributes);
    if (!accumulation) {
      if (this._activeCollectionStorage.size >= this._cardinalityLimit) {
        const overflowAccumulation = this._activeCollectionStorage.getOrDefault(this._overflowAttributes, () => this._aggregator.createAccumulation(collectionTime));
        overflowAccumulation?.record(value);
        return;
      }
      accumulation = this._aggregator.createAccumulation(collectionTime);
      this._activeCollectionStorage.set(attributes, accumulation);
    }
    accumulation?.record(value);
  }
  batchCumulate(measurements, collectionTime) {
    Array.from(measurements.entries()).forEach(([attributes, value, hashCode]) => {
      const accumulation = this._aggregator.createAccumulation(collectionTime);
      accumulation?.record(value);
      let delta = accumulation;
      // Diff with recorded cumulative memo.
      if (this._cumulativeMemoStorage.has(attributes, hashCode)) {
        // has() returned true, previous is present.
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const previous = this._cumulativeMemoStorage.get(attributes, hashCode);
        delta = this._aggregator.diff(previous, accumulation);
      } else {
        // If the cardinality limit is reached, we need to change the attributes
        if (this._cumulativeMemoStorage.size >= this._cardinalityLimit) {
          attributes = this._overflowAttributes;
          hashCode = this._overflowHashCode;
          if (this._cumulativeMemoStorage.has(attributes, hashCode)) {
            // has() returned true, previous is present.
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const previous = this._cumulativeMemoStorage.get(attributes, hashCode);
            delta = this._aggregator.diff(previous, accumulation);
          }
        }
      }
      // Merge with uncollected active delta.
      if (this._activeCollectionStorage.has(attributes, hashCode)) {
        // has() returned true, active is present.
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const active = this._activeCollectionStorage.get(attributes, hashCode);
        delta = this._aggregator.merge(active, delta);
      }
      // Save the current record and the delta record.
      this._cumulativeMemoStorage.set(attributes, accumulation, hashCode);
      this._activeCollectionStorage.set(attributes, delta, hashCode);
    });
  }
  /**
   * Returns a collection of delta metrics. Start time is the when first
   * time event collected.
   */
  collect() {
    const unreportedDelta = this._activeCollectionStorage;
    this._activeCollectionStorage = new AttributeHashMap();
    return unreportedDelta;
  }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Internal interface.
 *
 * Provides unique reporting for each collector. Allows synchronous collection
 * of metrics and reports given temporality values.
 */
class TemporalMetricProcessor {
  _aggregator;
  _unreportedAccumulations = new Map();
  _reportHistory = new Map();
  constructor(_aggregator, collectorHandles) {
    this._aggregator = _aggregator;
    collectorHandles.forEach(handle => {
      this._unreportedAccumulations.set(handle, []);
    });
  }
  /**
   * Builds the {@link MetricData} streams to report against a specific MetricCollector.
   * @param collector The information of the MetricCollector.
   * @param collectors The registered collectors.
   * @param instrumentDescriptor The instrumentation descriptor that these metrics generated with.
   * @param currentAccumulations The current accumulation of metric data from instruments.
   * @param collectionTime The current collection timestamp.
   * @returns The {@link MetricData} points or `null`.
   */
  buildMetrics(collector, instrumentDescriptor, currentAccumulations, collectionTime) {
    this._stashAccumulations(currentAccumulations);
    const unreportedAccumulations = this._getMergedUnreportedAccumulations(collector);
    let result = unreportedAccumulations;
    let aggregationTemporality;
    // Check our last report time.
    if (this._reportHistory.has(collector)) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const last = this._reportHistory.get(collector);
      const lastCollectionTime = last.collectionTime;
      aggregationTemporality = last.aggregationTemporality;
      // Use aggregation temporality + instrument to determine if we do a merge or a diff of
      // previous. We have the following four scenarios:
      // 1. Cumulative Aggregation (temporality) + Delta recording (sync instrument).
      //    Here we merge with our last record to get a cumulative aggregation.
      // 2. Cumulative Aggregation + Cumulative recording (async instrument).
      //    Cumulative records are converted to delta recording with DeltaMetricProcessor.
      //    Here we merge with our last record to get a cumulative aggregation.
      // 3. Delta Aggregation + Delta recording
      //    Calibrate the startTime of metric streams to be the reader's lastCollectionTime.
      // 4. Delta Aggregation + Cumulative recording.
      //    Cumulative records are converted to delta recording with DeltaMetricProcessor.
      //    Calibrate the startTime of metric streams to be the reader's lastCollectionTime.
      if (aggregationTemporality === AggregationTemporality.CUMULATIVE) {
        // We need to make sure the current delta recording gets merged into the previous cumulative
        // for the next cumulative recording.
        result = TemporalMetricProcessor.merge(last.accumulations, unreportedAccumulations, this._aggregator);
      } else {
        result = TemporalMetricProcessor.calibrateStartTime(last.accumulations, unreportedAccumulations, lastCollectionTime);
      }
    } else {
      // Call into user code to select aggregation temporality for the instrument.
      aggregationTemporality = collector.selectAggregationTemporality(instrumentDescriptor.type);
    }
    // Update last reported (cumulative) accumulation.
    this._reportHistory.set(collector, {
      accumulations: result,
      collectionTime,
      aggregationTemporality
    });
    const accumulationRecords = AttributesMapToAccumulationRecords(result);
    // do not convert to metric data if there is nothing to convert.
    if (accumulationRecords.length === 0) {
      return undefined;
    }
    return this._aggregator.toMetricData(instrumentDescriptor, aggregationTemporality, accumulationRecords, /* endTime */collectionTime);
  }
  _stashAccumulations(currentAccumulation) {
    const registeredCollectors = this._unreportedAccumulations.keys();
    for (const collector of registeredCollectors) {
      let stash = this._unreportedAccumulations.get(collector);
      if (stash === undefined) {
        stash = [];
        this._unreportedAccumulations.set(collector, stash);
      }
      stash.push(currentAccumulation);
    }
  }
  _getMergedUnreportedAccumulations(collector) {
    let result = new AttributeHashMap();
    const unreportedList = this._unreportedAccumulations.get(collector);
    this._unreportedAccumulations.set(collector, []);
    if (unreportedList === undefined) {
      return result;
    }
    for (const it of unreportedList) {
      result = TemporalMetricProcessor.merge(result, it, this._aggregator);
    }
    return result;
  }
  static merge(last, current, aggregator) {
    const result = last;
    const iterator = current.entries();
    let next = iterator.next();
    while (next.done !== true) {
      const [key, record, hash] = next.value;
      if (last.has(key, hash)) {
        const lastAccumulation = last.get(key, hash);
        // last.has() returned true, lastAccumulation is present.
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const accumulation = aggregator.merge(lastAccumulation, record);
        result.set(key, accumulation, hash);
      } else {
        result.set(key, record, hash);
      }
      next = iterator.next();
    }
    return result;
  }
  /**
   * Calibrate the reported metric streams' startTime to lastCollectionTime. Leaves
   * the new stream to be the initial observation time unchanged.
   */
  static calibrateStartTime(last, current, lastCollectionTime) {
    for (const [key, hash] of last.keys()) {
      const currentAccumulation = current.get(key, hash);
      currentAccumulation?.setStartTime(lastCollectionTime);
    }
    return current;
  }
}
// TypeScript complains about converting 3 elements tuple to AccumulationRecord<T>.
function AttributesMapToAccumulationRecords(map) {
  return Array.from(map.entries());
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Internal interface.
 *
 * Stores and aggregates {@link MetricData} for asynchronous instruments.
 */
class AsyncMetricStorage extends MetricStorage {
  _attributesProcessor;
  _aggregationCardinalityLimit;
  _deltaMetricStorage;
  _temporalMetricStorage;
  constructor(_instrumentDescriptor, aggregator, _attributesProcessor, collectorHandles, _aggregationCardinalityLimit) {
    super(_instrumentDescriptor);
    this._attributesProcessor = _attributesProcessor;
    this._aggregationCardinalityLimit = _aggregationCardinalityLimit;
    this._deltaMetricStorage = new DeltaMetricProcessor(aggregator, this._aggregationCardinalityLimit);
    this._temporalMetricStorage = new TemporalMetricProcessor(aggregator, collectorHandles);
  }
  record(measurements, observationTime) {
    const processed = new AttributeHashMap();
    Array.from(measurements.entries()).forEach(([attributes, value]) => {
      processed.set(this._attributesProcessor.process(attributes), value);
    });
    this._deltaMetricStorage.batchCumulate(processed, observationTime);
  }
  /**
   * Collects the metrics from this storage. The ObservableCallback is invoked
   * during the collection.
   *
   * Note: This is a stateful operation and may reset any interval-related
   * state for the MetricCollector.
   */
  collect(collector, collectionTime) {
    const accumulations = this._deltaMetricStorage.collect();
    return this._temporalMetricStorage.buildMetrics(collector, this._instrumentDescriptor, accumulations, collectionTime);
  }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getIncompatibilityDetails(existing, otherDescriptor) {
  let incompatibility = '';
  if (existing.unit !== otherDescriptor.unit) {
    incompatibility += `\t- Unit '${existing.unit}' does not match '${otherDescriptor.unit}'\n`;
  }
  if (existing.type !== otherDescriptor.type) {
    incompatibility += `\t- Type '${existing.type}' does not match '${otherDescriptor.type}'\n`;
  }
  if (existing.valueType !== otherDescriptor.valueType) {
    incompatibility += `\t- Value Type '${existing.valueType}' does not match '${otherDescriptor.valueType}'\n`;
  }
  if (existing.description !== otherDescriptor.description) {
    incompatibility += `\t- Description '${existing.description}' does not match '${otherDescriptor.description}'\n`;
  }
  return incompatibility;
}
function getValueTypeConflictResolutionRecipe(existing, otherDescriptor) {
  return `\t- use valueType '${existing.valueType}' on instrument creation or use an instrument name other than '${otherDescriptor.name}'`;
}
function getUnitConflictResolutionRecipe(existing, otherDescriptor) {
  return `\t- use unit '${existing.unit}' on instrument creation or use an instrument name other than '${otherDescriptor.name}'`;
}
function getTypeConflictResolutionRecipe(existing, otherDescriptor) {
  const selector = {
    name: otherDescriptor.name,
    type: otherDescriptor.type,
    unit: otherDescriptor.unit
  };
  const selectorString = JSON.stringify(selector);
  return `\t- create a new view with a name other than '${existing.name}' and InstrumentSelector '${selectorString}'`;
}
function getDescriptionResolutionRecipe(existing, otherDescriptor) {
  const selector = {
    name: otherDescriptor.name,
    type: otherDescriptor.type,
    unit: otherDescriptor.unit
  };
  const selectorString = JSON.stringify(selector);
  return `\t- create a new view with a name other than '${existing.name}' and InstrumentSelector '${selectorString}'
    \t- OR - create a new view with the name ${existing.name} and description '${existing.description}' and InstrumentSelector ${selectorString}
    \t- OR - create a new view with the name ${otherDescriptor.name} and description '${existing.description}' and InstrumentSelector ${selectorString}`;
}
function getConflictResolutionRecipe(existing, otherDescriptor) {
  // Conflicts that cannot be solved via views.
  if (existing.valueType !== otherDescriptor.valueType) {
    return getValueTypeConflictResolutionRecipe(existing, otherDescriptor);
  }
  if (existing.unit !== otherDescriptor.unit) {
    return getUnitConflictResolutionRecipe(existing, otherDescriptor);
  }
  // Conflicts that can be solved via views.
  if (existing.type !== otherDescriptor.type) {
    // this will automatically solve possible description conflicts.
    return getTypeConflictResolutionRecipe(existing, otherDescriptor);
  }
  if (existing.description !== otherDescriptor.description) {
    return getDescriptionResolutionRecipe(existing, otherDescriptor);
  }
  return '';
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Internal class for storing {@link MetricStorage}
 */
class MetricStorageRegistry {
  _sharedRegistry = new Map();
  _perCollectorRegistry = new Map();
  static create() {
    return new MetricStorageRegistry();
  }
  getStorages(collector) {
    let storages = [];
    for (const metricStorages of this._sharedRegistry.values()) {
      storages = storages.concat(metricStorages);
    }
    const perCollectorStorages = this._perCollectorRegistry.get(collector);
    if (perCollectorStorages != null) {
      for (const metricStorages of perCollectorStorages.values()) {
        storages = storages.concat(metricStorages);
      }
    }
    return storages;
  }
  register(storage) {
    this._registerStorage(storage, this._sharedRegistry);
  }
  registerForCollector(collector, storage) {
    let storageMap = this._perCollectorRegistry.get(collector);
    if (storageMap == null) {
      storageMap = new Map();
      this._perCollectorRegistry.set(collector, storageMap);
    }
    this._registerStorage(storage, storageMap);
  }
  findOrUpdateCompatibleStorage(expectedDescriptor) {
    const storages = this._sharedRegistry.get(expectedDescriptor.name);
    if (storages === undefined) {
      return null;
    }
    // If the descriptor is compatible, the type of their metric storage
    // (either SyncMetricStorage or AsyncMetricStorage) must be compatible.
    return this._findOrUpdateCompatibleStorage(expectedDescriptor, storages);
  }
  findOrUpdateCompatibleCollectorStorage(collector, expectedDescriptor) {
    const storageMap = this._perCollectorRegistry.get(collector);
    if (storageMap === undefined) {
      return null;
    }
    const storages = storageMap.get(expectedDescriptor.name);
    if (storages === undefined) {
      return null;
    }
    // If the descriptor is compatible, the type of their metric storage
    // (either SyncMetricStorage or AsyncMetricStorage) must be compatible.
    return this._findOrUpdateCompatibleStorage(expectedDescriptor, storages);
  }
  _registerStorage(storage, storageMap) {
    const descriptor = storage.getInstrumentDescriptor();
    const storages = storageMap.get(descriptor.name);
    if (storages === undefined) {
      storageMap.set(descriptor.name, [storage]);
      return;
    }
    storages.push(storage);
  }
  _findOrUpdateCompatibleStorage(expectedDescriptor, existingStorages) {
    let compatibleStorage = null;
    for (const existingStorage of existingStorages) {
      const existingDescriptor = existingStorage.getInstrumentDescriptor();
      if (isDescriptorCompatibleWith(existingDescriptor, expectedDescriptor)) {
        // Use the longer description if it does not match.
        if (existingDescriptor.description !== expectedDescriptor.description) {
          if (expectedDescriptor.description.length > existingDescriptor.description.length) {
            existingStorage.updateDescription(expectedDescriptor.description);
          }
          api__namespace.diag.warn('A view or instrument with the name ', expectedDescriptor.name, ' has already been registered, but has a different description and is incompatible with another registered view.\n', 'Details:\n', getIncompatibilityDetails(existingDescriptor, expectedDescriptor), 'The longer description will be used.\nTo resolve the conflict:', getConflictResolutionRecipe(existingDescriptor, expectedDescriptor));
        }
        // Storage is fully compatible. There will never be more than one pre-existing fully compatible storage.
        compatibleStorage = existingStorage;
      } else {
        // The implementation SHOULD warn about duplicate instrument registration
        // conflicts after applying View configuration.
        api__namespace.diag.warn('A view or instrument with the name ', expectedDescriptor.name, ' has already been registered and is incompatible with another registered view.\n', 'Details:\n', getIncompatibilityDetails(existingDescriptor, expectedDescriptor), 'To resolve the conflict:\n', getConflictResolutionRecipe(existingDescriptor, expectedDescriptor));
      }
    }
    return compatibleStorage;
  }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Internal interface.
 */
class MultiMetricStorage {
  _backingStorages;
  constructor(_backingStorages) {
    this._backingStorages = _backingStorages;
  }
  record(value, attributes, context, recordTime) {
    this._backingStorages.forEach(it => {
      it.record(value, attributes, context, recordTime);
    });
  }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The class implements {@link ObservableResult} interface.
 */
class ObservableResultImpl {
  _instrumentName;
  _valueType;
  /**
   * @internal
   */
  _buffer = new AttributeHashMap();
  constructor(_instrumentName, _valueType) {
    this._instrumentName = _instrumentName;
    this._valueType = _valueType;
  }
  /**
   * Observe a measurement of the value associated with the given attributes.
   */
  observe(value, attributes = {}) {
    if (typeof value !== 'number') {
      api.diag.warn(`non-number value provided to metric ${this._instrumentName}: ${value}`);
      return;
    }
    if (this._valueType === api.ValueType.INT && !Number.isInteger(value)) {
      api.diag.warn(`INT value type cannot accept a floating-point value for ${this._instrumentName}, ignoring the fractional digits.`);
      value = Math.trunc(value);
      // ignore non-finite values.
      if (!Number.isInteger(value)) {
        return;
      }
    }
    this._buffer.set(attributes, value);
  }
}
/**
 * The class implements {@link BatchObservableCallback} interface.
 */
class BatchObservableResultImpl {
  /**
   * @internal
   */
  _buffer = new Map();
  /**
   * Observe a measurement of the value associated with the given attributes.
   */
  observe(metric, value, attributes = {}) {
    if (!isObservableInstrument(metric)) {
      return;
    }
    let map = this._buffer.get(metric);
    if (map == null) {
      map = new AttributeHashMap();
      this._buffer.set(metric, map);
    }
    if (typeof value !== 'number') {
      api.diag.warn(`non-number value provided to metric ${metric._descriptor.name}: ${value}`);
      return;
    }
    if (metric._descriptor.valueType === api.ValueType.INT && !Number.isInteger(value)) {
      api.diag.warn(`INT value type cannot accept a floating-point value for ${metric._descriptor.name}, ignoring the fractional digits.`);
      value = Math.trunc(value);
      // ignore non-finite values.
      if (!Number.isInteger(value)) {
        return;
      }
    }
    map.set(attributes, value);
  }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * An internal interface for managing ObservableCallbacks.
 *
 * Every registered callback associated with a set of instruments are be evaluated
 * exactly once during collection prior to reading data for that instrument.
 */
class ObservableRegistry {
  _callbacks = [];
  _batchCallbacks = [];
  addCallback(callback, instrument) {
    const idx = this._findCallback(callback, instrument);
    if (idx >= 0) {
      return;
    }
    this._callbacks.push({
      callback,
      instrument
    });
  }
  removeCallback(callback, instrument) {
    const idx = this._findCallback(callback, instrument);
    if (idx < 0) {
      return;
    }
    this._callbacks.splice(idx, 1);
  }
  addBatchCallback(callback, instruments) {
    // Create a set of unique instruments.
    const observableInstruments = new Set(instruments.filter(isObservableInstrument));
    if (observableInstruments.size === 0) {
      api.diag.error('BatchObservableCallback is not associated with valid instruments', instruments);
      return;
    }
    const idx = this._findBatchCallback(callback, observableInstruments);
    if (idx >= 0) {
      return;
    }
    this._batchCallbacks.push({
      callback,
      instruments: observableInstruments
    });
  }
  removeBatchCallback(callback, instruments) {
    // Create a set of unique instruments.
    const observableInstruments = new Set(instruments.filter(isObservableInstrument));
    const idx = this._findBatchCallback(callback, observableInstruments);
    if (idx < 0) {
      return;
    }
    this._batchCallbacks.splice(idx, 1);
  }
  /**
   * @returns a promise of rejected reasons for invoking callbacks.
   */
  async observe(collectionTime, timeoutMillis) {
    const callbackFutures = this._observeCallbacks(collectionTime, timeoutMillis);
    const batchCallbackFutures = this._observeBatchCallbacks(collectionTime, timeoutMillis);
    const results = await PromiseAllSettled([...callbackFutures, ...batchCallbackFutures]);
    const rejections = results.filter(isPromiseAllSettledRejectionResult).map(it => it.reason);
    return rejections;
  }
  _observeCallbacks(observationTime, timeoutMillis) {
    return this._callbacks.map(async ({
      callback,
      instrument
    }) => {
      const observableResult = new ObservableResultImpl(instrument._descriptor.name, instrument._descriptor.valueType);
      let callPromise = Promise.resolve(callback(observableResult));
      if (timeoutMillis != null) {
        callPromise = callWithTimeout(callPromise, timeoutMillis);
      }
      await callPromise;
      instrument._metricStorages.forEach(metricStorage => {
        metricStorage.record(observableResult._buffer, observationTime);
      });
    });
  }
  _observeBatchCallbacks(observationTime, timeoutMillis) {
    return this._batchCallbacks.map(async ({
      callback,
      instruments
    }) => {
      const observableResult = new BatchObservableResultImpl();
      let callPromise = Promise.resolve(callback(observableResult));
      if (timeoutMillis != null) {
        callPromise = callWithTimeout(callPromise, timeoutMillis);
      }
      await callPromise;
      instruments.forEach(instrument => {
        const buffer = observableResult._buffer.get(instrument);
        if (buffer == null) {
          return;
        }
        instrument._metricStorages.forEach(metricStorage => {
          metricStorage.record(buffer, observationTime);
        });
      });
    });
  }
  _findCallback(callback, instrument) {
    return this._callbacks.findIndex(record => {
      return record.callback === callback && record.instrument === instrument;
    });
  }
  _findBatchCallback(callback, instruments) {
    return this._batchCallbacks.findIndex(record => {
      return record.callback === callback && setEquals(record.instruments, instruments);
    });
  }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Internal interface.
 *
 * Stores and aggregates {@link MetricData} for synchronous instruments.
 */
class SyncMetricStorage extends MetricStorage {
  _attributesProcessor;
  _aggregationCardinalityLimit;
  _deltaMetricStorage;
  _temporalMetricStorage;
  constructor(instrumentDescriptor, aggregator, _attributesProcessor, collectorHandles, _aggregationCardinalityLimit) {
    super(instrumentDescriptor);
    this._attributesProcessor = _attributesProcessor;
    this._aggregationCardinalityLimit = _aggregationCardinalityLimit;
    this._deltaMetricStorage = new DeltaMetricProcessor(aggregator, this._aggregationCardinalityLimit);
    this._temporalMetricStorage = new TemporalMetricProcessor(aggregator, collectorHandles);
  }
  record(value, attributes, context, recordTime) {
    attributes = this._attributesProcessor.process(attributes, context);
    this._deltaMetricStorage.record(value, attributes, context, recordTime);
  }
  /**
   * Collects the metrics from this storage.
   *
   * Note: This is a stateful operation and may reset any interval-related
   * state for the MetricCollector.
   */
  collect(collector, collectionTime) {
    const accumulations = this._deltaMetricStorage.collect();
    return this._temporalMetricStorage.buildMetrics(collector, this._instrumentDescriptor, accumulations, collectionTime);
  }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class NoopAttributesProcessor {
  process(incoming, _context) {
    return incoming;
  }
}
class MultiAttributesProcessor {
  _processors;
  constructor(_processors) {
    this._processors = _processors;
  }
  process(incoming, context) {
    let filteredAttributes = incoming;
    for (const processor of this._processors) {
      filteredAttributes = processor.process(filteredAttributes, context);
    }
    return filteredAttributes;
  }
}
/**
 * @internal
 *
 * Create an {@link IAttributesProcessor} that acts as a simple pass-through for attributes.
 */
function createNoopAttributesProcessor() {
  return NOOP;
}
/**
 * @internal
 *
 * Create an {@link IAttributesProcessor} that applies all processors from the provided list in order.
 *
 * @param processors Processors to apply in order.
 */
function createMultiAttributesProcessor(processors) {
  return new MultiAttributesProcessor(processors);
}
const NOOP = new NoopAttributesProcessor();

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * An internal record for shared meter provider states.
 */
class MeterSharedState {
  _meterProviderSharedState;
  _instrumentationScope;
  metricStorageRegistry = new MetricStorageRegistry();
  observableRegistry = new ObservableRegistry();
  meter;
  constructor(_meterProviderSharedState, _instrumentationScope) {
    this._meterProviderSharedState = _meterProviderSharedState;
    this._instrumentationScope = _instrumentationScope;
    this.meter = new Meter(this);
  }
  registerMetricStorage(descriptor) {
    const storages = this._registerMetricStorage(descriptor, SyncMetricStorage);
    if (storages.length === 1) {
      return storages[0];
    }
    return new MultiMetricStorage(storages);
  }
  registerAsyncMetricStorage(descriptor) {
    const storages = this._registerMetricStorage(descriptor, AsyncMetricStorage);
    return storages;
  }
  /**
   * @param collector opaque handle of {@link MetricCollector} which initiated the collection.
   * @param collectionTime the HrTime at which the collection was initiated.
   * @param options options for collection.
   * @returns the list of metric data collected.
   */
  async collect(collector, collectionTime, options) {
    /**
     * 1. Call all observable callbacks first.
     * 2. Collect metric result for the collector.
     */
    const errors = await this.observableRegistry.observe(collectionTime, options?.timeoutMillis);
    const storages = this.metricStorageRegistry.getStorages(collector);
    // prevent more allocations if there are no storages.
    if (storages.length === 0) {
      return null;
    }
    const metricDataList = storages.map(metricStorage => {
      return metricStorage.collect(collector, collectionTime);
    }).filter(isNotNullish);
    // skip this scope if no data was collected (storage created, but no data observed)
    if (metricDataList.length === 0) {
      return {
        errors
      };
    }
    return {
      scopeMetrics: {
        scope: this._instrumentationScope,
        metrics: metricDataList
      },
      errors
    };
  }
  _registerMetricStorage(descriptor, MetricStorageType) {
    const views = this._meterProviderSharedState.viewRegistry.findViews(descriptor, this._instrumentationScope);
    let storages = views.map(view => {
      const viewDescriptor = createInstrumentDescriptorWithView(view, descriptor);
      const compatibleStorage = this.metricStorageRegistry.findOrUpdateCompatibleStorage(viewDescriptor);
      if (compatibleStorage != null) {
        return compatibleStorage;
      }
      const aggregator = view.aggregation.createAggregator(viewDescriptor);
      const viewStorage = new MetricStorageType(viewDescriptor, aggregator, view.attributesProcessor, this._meterProviderSharedState.metricCollectors, view.aggregationCardinalityLimit);
      this.metricStorageRegistry.register(viewStorage);
      return viewStorage;
    });
    // Fallback to the per-collector aggregations if no view is configured for the instrument.
    if (storages.length === 0) {
      const perCollectorAggregations = this._meterProviderSharedState.selectAggregations(descriptor.type);
      const collectorStorages = perCollectorAggregations.map(([collector, aggregation]) => {
        const compatibleStorage = this.metricStorageRegistry.findOrUpdateCompatibleCollectorStorage(collector, descriptor);
        if (compatibleStorage != null) {
          return compatibleStorage;
        }
        const aggregator = aggregation.createAggregator(descriptor);
        const cardinalityLimit = collector.selectCardinalityLimit(descriptor.type);
        const storage = new MetricStorageType(descriptor, aggregator, createNoopAttributesProcessor(), [collector], cardinalityLimit);
        this.metricStorageRegistry.registerForCollector(collector, storage);
        return storage;
      });
      storages = storages.concat(collectorStorages);
    }
    return storages;
  }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * An internal record for shared meter provider states.
 */
class MeterProviderSharedState {
  resource;
  viewRegistry = new ViewRegistry();
  metricCollectors = [];
  meterSharedStates = new Map();
  constructor(resource) {
    this.resource = resource;
  }
  getMeterSharedState(instrumentationScope) {
    const id = instrumentationScopeId(instrumentationScope);
    let meterSharedState = this.meterSharedStates.get(id);
    if (meterSharedState == null) {
      meterSharedState = new MeterSharedState(this, instrumentationScope);
      this.meterSharedStates.set(id, meterSharedState);
    }
    return meterSharedState;
  }
  selectAggregations(instrumentType) {
    const result = [];
    for (const collector of this.metricCollectors) {
      result.push([collector, toAggregation(collector.selectAggregation(instrumentType))]);
    }
    return result;
  }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * An internal opaque interface that the MetricReader receives as
 * MetricProducer. It acts as the storage key to the internal metric stream
 * state for each MetricReader.
 */
class MetricCollector {
  _sharedState;
  _metricReader;
  constructor(_sharedState, _metricReader) {
    this._sharedState = _sharedState;
    this._metricReader = _metricReader;
  }
  async collect(options) {
    const collectionTime = core.millisToHrTime(Date.now());
    const scopeMetrics = [];
    const errors = [];
    const meterCollectionPromises = Array.from(this._sharedState.meterSharedStates.values()).map(async meterSharedState => {
      const current = await meterSharedState.collect(this, collectionTime, options);
      // only add scope metrics if available
      if (current?.scopeMetrics != null) {
        scopeMetrics.push(current.scopeMetrics);
      }
      // only add errors if available
      if (current?.errors != null) {
        errors.push(...current.errors);
      }
    });
    await Promise.all(meterCollectionPromises);
    return {
      resourceMetrics: {
        resource: this._sharedState.resource,
        scopeMetrics: scopeMetrics
      },
      errors: errors
    };
  }
  /**
   * Delegates for MetricReader.forceFlush.
   */
  async forceFlush(options) {
    await this._metricReader.forceFlush(options);
  }
  /**
   * Delegates for MetricReader.shutdown.
   */
  async shutdown(options) {
    await this._metricReader.shutdown(options);
  }
  selectAggregationTemporality(instrumentType) {
    return this._metricReader.selectAggregationTemporality(instrumentType);
  }
  selectAggregation(instrumentType) {
    return this._metricReader.selectAggregation(instrumentType);
  }
  /**
   * Select the cardinality limit for the given {@link InstrumentType} for this
   * collector.
   */
  selectCardinalityLimit(instrumentType) {
    return this._metricReader.selectCardinalityLimit?.(instrumentType) ?? 2000;
  }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// https://tc39.es/proposal-regex-escaping
// escape ^ $ \ .  + ? ( ) [ ] { } |
// do not need to escape * as we interpret it as wildcard
const ESCAPE = /[\^$\\.+?()[\]{}|]/g;
/**
 * Wildcard pattern predicate, supports patterns like `*`, `foo*`, `*bar`.
 */
class PatternPredicate {
  _matchAll;
  _regexp;
  constructor(pattern) {
    if (pattern === '*') {
      this._matchAll = true;
      this._regexp = /.*/;
    } else {
      this._matchAll = false;
      this._regexp = new RegExp(PatternPredicate.escapePattern(pattern));
    }
  }
  match(str) {
    if (this._matchAll) {
      return true;
    }
    return this._regexp.test(str);
  }
  static escapePattern(pattern) {
    return `^${pattern.replace(ESCAPE, '\\$&').replace('*', '.*')}$`;
  }
  static hasWildcard(pattern) {
    return pattern.includes('*');
  }
}
class ExactPredicate {
  _matchAll;
  _pattern;
  constructor(pattern) {
    this._matchAll = pattern === undefined;
    this._pattern = pattern;
  }
  match(str) {
    if (this._matchAll) {
      return true;
    }
    if (str === this._pattern) {
      return true;
    }
    return false;
  }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class InstrumentSelector {
  _nameFilter;
  _type;
  _unitFilter;
  constructor(criteria) {
    this._nameFilter = new PatternPredicate(criteria?.name ?? '*');
    this._type = criteria?.type;
    this._unitFilter = new ExactPredicate(criteria?.unit);
  }
  getType() {
    return this._type;
  }
  getNameFilter() {
    return this._nameFilter;
  }
  getUnitFilter() {
    return this._unitFilter;
  }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class MeterSelector {
  _nameFilter;
  _versionFilter;
  _schemaUrlFilter;
  constructor(criteria) {
    this._nameFilter = new ExactPredicate(criteria?.name);
    this._versionFilter = new ExactPredicate(criteria?.version);
    this._schemaUrlFilter = new ExactPredicate(criteria?.schemaUrl);
  }
  getNameFilter() {
    return this._nameFilter;
  }
  /**
   * TODO: semver filter? no spec yet.
   */
  getVersionFilter() {
    return this._versionFilter;
  }
  getSchemaUrlFilter() {
    return this._schemaUrlFilter;
  }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function isSelectorNotProvided(options) {
  return options.instrumentName == null && options.instrumentType == null && options.instrumentUnit == null && options.meterName == null && options.meterVersion == null && options.meterSchemaUrl == null;
}
function validateViewOptions(viewOptions) {
  // If no criteria is provided, the SDK SHOULD treat it as an error.
  // It is recommended that the SDK implementations fail fast.
  if (isSelectorNotProvided(viewOptions)) {
    throw new Error('Cannot create view with no selector arguments supplied');
  }
  // the SDK SHOULD NOT allow Views with a specified name to be declared with instrument selectors that
  // may select more than one instrument (e.g. wild card instrument name) in the same Meter.
  if (viewOptions.name != null && (viewOptions?.instrumentName == null || PatternPredicate.hasWildcard(viewOptions.instrumentName))) {
    throw new Error('Views with a specified name must be declared with an instrument selector that selects at most one instrument per meter.');
  }
}
/**
 * Can be passed to a {@link MeterProvider} to select instruments and alter their metric stream.
 */
class View {
  name;
  description;
  aggregation;
  attributesProcessor;
  instrumentSelector;
  meterSelector;
  aggregationCardinalityLimit;
  /**
   * Create a new {@link View} instance.
   *
   * Parameters can be categorized as two types:
   *  Instrument selection criteria: Used to describe the instrument(s) this view will be applied to.
   *  Will be treated as additive (the Instrument has to meet all the provided criteria to be selected).
   *
   *  Metric stream altering: Alter the metric stream of instruments selected by instrument selection criteria.
   *
   * @param viewOptions {@link ViewOptions} for altering the metric stream and instrument selection.
   * @param viewOptions.name
   * Alters the metric stream:
   *  This will be used as the name of the metrics stream.
   *  If not provided, the original Instrument name will be used.
   * @param viewOptions.description
   * Alters the metric stream:
   *  This will be used as the description of the metrics stream.
   *  If not provided, the original Instrument description will be used by default.
   * @param viewOptions.attributesProcessors
   * Alters the metric stream:
   *  If provided, the attributes will be modified as defined by the added processors.
   *  If not provided, all attribute keys will be used by default.
   * @param viewOptions.aggregationCardinalityLimit
   * Alters the metric stream:
   *  Sets a limit on the number of unique attribute combinations (cardinality) that can be aggregated.
   *  If not provided, the default limit of 2000 will be used.
   * @param viewOptions.aggregation
   * Alters the metric stream:
   *  Alters the {@link Aggregation} of the metric stream.
   * @param viewOptions.instrumentName
   * Instrument selection criteria:
   *  Original name of the Instrument(s) with wildcard support.
   * @param viewOptions.instrumentType
   * Instrument selection criteria:
   *  The original type of the Instrument(s).
   * @param viewOptions.instrumentUnit
   * Instrument selection criteria:
   *  The unit of the Instrument(s).
   * @param viewOptions.meterName
   * Instrument selection criteria:
   *  The name of the Meter. No wildcard support, name must match the meter exactly.
   * @param viewOptions.meterVersion
   * Instrument selection criteria:
   *  The version of the Meter. No wildcard support, version must match exactly.
   * @param viewOptions.meterSchemaUrl
   * Instrument selection criteria:
   *  The schema URL of the Meter. No wildcard support, schema URL must match exactly.
   *
   * @example
   * // Create a view that changes the Instrument 'my.instrument' to use to an
   * // ExplicitBucketHistogramAggregation with the boundaries [20, 30, 40]
   * new View({
   *   aggregation: new ExplicitBucketHistogramAggregation([20, 30, 40]),
   *   instrumentName: 'my.instrument'
   * })
   */
  constructor(viewOptions) {
    validateViewOptions(viewOptions);
    // Create multi-processor if attributesProcessors are defined.
    if (viewOptions.attributesProcessors != null) {
      this.attributesProcessor = createMultiAttributesProcessor(viewOptions.attributesProcessors);
    } else {
      this.attributesProcessor = createNoopAttributesProcessor();
    }
    this.name = viewOptions.name;
    this.description = viewOptions.description;
    this.aggregation = toAggregation(viewOptions.aggregation ?? {
      type: AggregationType.DEFAULT
    });
    this.instrumentSelector = new InstrumentSelector({
      name: viewOptions.instrumentName,
      type: viewOptions.instrumentType,
      unit: viewOptions.instrumentUnit
    });
    this.meterSelector = new MeterSelector({
      name: viewOptions.meterName,
      version: viewOptions.meterVersion,
      schemaUrl: viewOptions.meterSchemaUrl
    });
    this.aggregationCardinalityLimit = viewOptions.aggregationCardinalityLimit;
  }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This class implements the {@link MeterProvider} interface.
 */
class MeterProvider {
  _sharedState;
  _shutdown = false;
  constructor(options) {
    this._sharedState = new MeterProviderSharedState(options?.resource ?? resources.defaultResource());
    if (options?.views != null && options.views.length > 0) {
      for (const viewOption of options.views) {
        this._sharedState.viewRegistry.addView(new View(viewOption));
      }
    }
    if (options?.readers != null && options.readers.length > 0) {
      for (const metricReader of options.readers) {
        const collector = new MetricCollector(this._sharedState, metricReader);
        metricReader.setMetricProducer(collector);
        this._sharedState.metricCollectors.push(collector);
      }
    }
  }
  /**
   * Get a meter with the configuration of the MeterProvider.
   */
  getMeter(name, version = '', options = {}) {
    // https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/sdk.md#meter-creation
    if (this._shutdown) {
      api.diag.warn('A shutdown MeterProvider cannot provide a Meter');
      return api.createNoopMeter();
    }
    return this._sharedState.getMeterSharedState({
      name,
      version,
      schemaUrl: options.schemaUrl
    }).meter;
  }
  /**
   * Shut down the MeterProvider and all registered
   * MetricReaders.
   *
   * Returns a promise which is resolved when all flushes are complete.
   */
  async shutdown(options) {
    if (this._shutdown) {
      api.diag.warn('shutdown may only be called once per MeterProvider');
      return;
    }
    this._shutdown = true;
    await Promise.all(this._sharedState.metricCollectors.map(collector => {
      return collector.shutdown(options);
    }));
  }
  /**
   * Notifies all registered MetricReaders to flush any buffered data.
   *
   * Returns a promise which is resolved when all flushes are complete.
   */
  async forceFlush(options) {
    // do not flush after shutdown
    if (this._shutdown) {
      api.diag.warn('invalid attempt to force flush after MeterProvider shutdown');
      return;
    }
    await Promise.all(this._sharedState.metricCollectors.map(collector => {
      return collector.forceFlush(options);
    }));
  }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class NoopLogger {
  emit(_logRecord) {}
}
const NOOP_LOGGER = new NoopLogger();

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class NoopLoggerProvider {
  getLogger(_name, _version, _options) {
    return new NoopLogger();
  }
}
const NOOP_LOGGER_PROVIDER = new NoopLoggerProvider();

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProxyLogger {
  constructor(_provider, name, version, options) {
    this._provider = _provider;
    this.name = name;
    this.version = version;
    this.options = options;
  }
  /**
   * Emit a log record. This method should only be used by log appenders.
   *
   * @param logRecord
   */
  emit(logRecord) {
    this._getLogger().emit(logRecord);
  }
  /**
   * Try to get a logger from the proxy logger provider.
   * If the proxy logger provider has no delegate, return a noop logger.
   */
  _getLogger() {
    if (this._delegate) {
      return this._delegate;
    }
    const logger = this._provider.getDelegateLogger(this.name, this.version, this.options);
    if (!logger) {
      return NOOP_LOGGER;
    }
    this._delegate = logger;
    return this._delegate;
  }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProxyLoggerProvider {
  getLogger(name, version, options) {
    var _a;
    return (_a = this.getDelegateLogger(name, version, options)) !== null && _a !== void 0 ? _a : new ProxyLogger(this, name, version, options);
  }
  getDelegate() {
    var _a;
    return (_a = this._delegate) !== null && _a !== void 0 ? _a : NOOP_LOGGER_PROVIDER;
  }
  /**
   * Set the delegate logger provider
   */
  setDelegate(delegate) {
    this._delegate = delegate;
  }
  getDelegateLogger(name, version, options) {
    var _a;
    return (_a = this._delegate) === null || _a === void 0 ? void 0 : _a.getLogger(name, version, options);
  }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Updates to this file should also be replicated to @opentelemetry/api and
// @opentelemetry/core too.
/**
 * - globalThis (New standard)
 * - self (Will return the current window instance for supported browsers)
 * - window (fallback for older browser implementations)
 * - global (NodeJS implementation)
 * - <object> (When all else fails)
 */
/** only globals that common to node and browsers are allowed */
// eslint-disable-next-line node/no-unsupported-features/es-builtins, no-undef
const _globalThis = typeof globalThis === 'object' ? globalThis : typeof self === 'object' ? self : typeof window === 'object' ? window : typeof global === 'object' ? global : {};

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const GLOBAL_LOGS_API_KEY = Symbol.for('io.opentelemetry.js.api.logs');
const _global = _globalThis;
/**
 * Make a function which accepts a version integer and returns the instance of an API if the version
 * is compatible, or a fallback version (usually NOOP) if it is not.
 *
 * @param requiredVersion Backwards compatibility version which is required to return the instance
 * @param instance Instance which should be returned if the required version is compatible
 * @param fallback Fallback instance, usually NOOP, which will be returned if the required version is not compatible
 */
function makeGetter(requiredVersion, instance, fallback) {
  return version => version === requiredVersion ? instance : fallback;
}
/**
 * A number which should be incremented each time a backwards incompatible
 * change is made to the API. This number is used when an API package
 * attempts to access the global API to ensure it is getting a compatible
 * version. If the global API is not compatible with the API package
 * attempting to get it, a NOOP API implementation will be returned.
 */
const API_BACKWARDS_COMPATIBILITY_VERSION = 1;

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class LogsAPI {
  constructor() {
    this._proxyLoggerProvider = new ProxyLoggerProvider();
  }
  static getInstance() {
    if (!this._instance) {
      this._instance = new LogsAPI();
    }
    return this._instance;
  }
  setGlobalLoggerProvider(provider) {
    if (_global[GLOBAL_LOGS_API_KEY]) {
      return this.getLoggerProvider();
    }
    _global[GLOBAL_LOGS_API_KEY] = makeGetter(API_BACKWARDS_COMPATIBILITY_VERSION, provider, NOOP_LOGGER_PROVIDER);
    this._proxyLoggerProvider.setDelegate(provider);
    return provider;
  }
  /**
   * Returns the global logger provider.
   *
   * @returns LoggerProvider
   */
  getLoggerProvider() {
    var _a, _b;
    return (_b = (_a = _global[GLOBAL_LOGS_API_KEY]) === null || _a === void 0 ? void 0 : _a.call(_global, API_BACKWARDS_COMPATIBILITY_VERSION)) !== null && _b !== void 0 ? _b : this._proxyLoggerProvider;
  }
  /**
   * Returns a logger from the global logger provider.
   *
   * @returns Logger
   */
  getLogger(name, version, options) {
    return this.getLoggerProvider().getLogger(name, version, options);
  }
  /** Remove the global logger provider */
  disable() {
    delete _global[GLOBAL_LOGS_API_KEY];
    this._proxyLoggerProvider = new ProxyLoggerProvider();
  }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const logs = LogsAPI.getInstance();

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class LogRecordImpl {
  hrTime;
  hrTimeObserved;
  spanContext;
  resource;
  instrumentationScope;
  attributes = {};
  _severityText;
  _severityNumber;
  _body;
  _eventName;
  totalAttributesCount = 0;
  _isReadonly = false;
  _logRecordLimits;
  set severityText(severityText) {
    if (this._isLogRecordReadonly()) {
      return;
    }
    this._severityText = severityText;
  }
  get severityText() {
    return this._severityText;
  }
  set severityNumber(severityNumber) {
    if (this._isLogRecordReadonly()) {
      return;
    }
    this._severityNumber = severityNumber;
  }
  get severityNumber() {
    return this._severityNumber;
  }
  set body(body) {
    if (this._isLogRecordReadonly()) {
      return;
    }
    this._body = body;
  }
  get body() {
    return this._body;
  }
  get eventName() {
    return this._eventName;
  }
  set eventName(eventName) {
    if (this._isLogRecordReadonly()) {
      return;
    }
    this._eventName = eventName;
  }
  get droppedAttributesCount() {
    return this.totalAttributesCount - Object.keys(this.attributes).length;
  }
  constructor(_sharedState, instrumentationScope, logRecord) {
    const {
      timestamp,
      observedTimestamp,
      eventName,
      severityNumber,
      severityText,
      body,
      attributes = {},
      context
    } = logRecord;
    const now = Date.now();
    this.hrTime = core.timeInputToHrTime(timestamp ?? now);
    this.hrTimeObserved = core.timeInputToHrTime(observedTimestamp ?? now);
    if (context) {
      const spanContext = api__namespace.trace.getSpanContext(context);
      if (spanContext && api__namespace.isSpanContextValid(spanContext)) {
        this.spanContext = spanContext;
      }
    }
    this.severityNumber = severityNumber;
    this.severityText = severityText;
    this.body = body;
    this.resource = _sharedState.resource;
    this.instrumentationScope = instrumentationScope;
    this._logRecordLimits = _sharedState.logRecordLimits;
    this._eventName = eventName;
    this.setAttributes(attributes);
  }
  setAttribute(key, value) {
    if (this._isLogRecordReadonly()) {
      return this;
    }
    if (value === null) {
      return this;
    }
    if (key.length === 0) {
      api__namespace.diag.warn(`Invalid attribute key: ${key}`);
      return this;
    }
    if (!core.isAttributeValue(value) && !(typeof value === 'object' && !Array.isArray(value) && Object.keys(value).length > 0)) {
      api__namespace.diag.warn(`Invalid attribute value set for key: ${key}`);
      return this;
    }
    this.totalAttributesCount += 1;
    if (Object.keys(this.attributes).length >= this._logRecordLimits.attributeCountLimit && !Object.prototype.hasOwnProperty.call(this.attributes, key)) {
      // This logic is to create drop message at most once per LogRecord to prevent excessive logging.
      if (this.droppedAttributesCount === 1) {
        api__namespace.diag.warn('Dropping extra attributes.');
      }
      return this;
    }
    if (core.isAttributeValue(value)) {
      this.attributes[key] = this._truncateToSize(value);
    } else {
      this.attributes[key] = value;
    }
    return this;
  }
  setAttributes(attributes) {
    for (const [k, v] of Object.entries(attributes)) {
      this.setAttribute(k, v);
    }
    return this;
  }
  setBody(body) {
    this.body = body;
    return this;
  }
  setEventName(eventName) {
    this.eventName = eventName;
    return this;
  }
  setSeverityNumber(severityNumber) {
    this.severityNumber = severityNumber;
    return this;
  }
  setSeverityText(severityText) {
    this.severityText = severityText;
    return this;
  }
  /**
   * @internal
   * A LogRecordProcessor may freely modify logRecord for the duration of the OnEmit call.
   * If logRecord is needed after OnEmit returns (i.e. for asynchronous processing) only reads are permitted.
   */
  _makeReadonly() {
    this._isReadonly = true;
  }
  _truncateToSize(value) {
    const limit = this._logRecordLimits.attributeValueLengthLimit;
    // Check limit
    if (limit <= 0) {
      // Negative values are invalid, so do not truncate
      api__namespace.diag.warn(`Attribute value limit must be positive, got ${limit}`);
      return value;
    }
    // String
    if (typeof value === 'string') {
      return this._truncateToLimitUtil(value, limit);
    }
    // Array of strings
    if (Array.isArray(value)) {
      return value.map(val => typeof val === 'string' ? this._truncateToLimitUtil(val, limit) : val);
    }
    // Other types, no need to apply value length limit
    return value;
  }
  _truncateToLimitUtil(value, limit) {
    if (value.length <= limit) {
      return value;
    }
    return value.substring(0, limit);
  }
  _isLogRecordReadonly() {
    if (this._isReadonly) {
      api.diag.warn('Can not execute the operation on emitted log record');
    }
    return this._isReadonly;
  }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Logger {
  instrumentationScope;
  _sharedState;
  constructor(instrumentationScope, _sharedState) {
    this.instrumentationScope = instrumentationScope;
    this._sharedState = _sharedState;
  }
  emit(logRecord) {
    const currentContext = logRecord.context || api.context.active();
    /**
     * If a Logger was obtained with include_trace_context=true,
     * the LogRecords it emits MUST automatically include the Trace Context from the active Context,
     * if Context has not been explicitly set.
     */
    const logRecordInstance = new LogRecordImpl(this._sharedState, this.instrumentationScope, {
      context: currentContext,
      ...logRecord
    });
    /**
     * the explicitly passed Context,
     * the current Context, or an empty Context if the Logger was obtained with include_trace_context=false
     */
    this._sharedState.activeProcessor.onEmit(logRecordInstance, currentContext);
    /**
     * A LogRecordProcessor may freely modify logRecord for the duration of the OnEmit call.
     * If logRecord is needed after OnEmit returns (i.e. for asynchronous processing) only reads are permitted.
     */
    logRecordInstance._makeReadonly();
  }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function loadDefaultConfig() {
  return {
    forceFlushTimeoutMillis: 30000,
    logRecordLimits: {
      attributeValueLengthLimit: core.getNumberFromEnv('OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT') ?? Infinity,
      attributeCountLimit: core.getNumberFromEnv('OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT') ?? 128
    },
    includeTraceContext: true
  };
}
/**
 * When general limits are provided and model specific limits are not,
 * configures the model specific limits by using the values from the general ones.
 * @param logRecordLimits User provided limits configuration
 */
function reconfigureLimits(logRecordLimits) {
  return {
    /**
     * Reassign log record attribute count limit to use first non null value defined by user or use default value
     */
    attributeCountLimit: logRecordLimits.attributeCountLimit ?? core.getNumberFromEnv('OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT') ?? core.getNumberFromEnv('OTEL_ATTRIBUTE_COUNT_LIMIT') ?? 128,
    /**
     * Reassign log record attribute value length limit to use first non null value defined by user or use default value
     */
    attributeValueLengthLimit: logRecordLimits.attributeValueLengthLimit ?? core.getNumberFromEnv('OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT') ?? core.getNumberFromEnv('OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT') ?? Infinity
  };
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class NoopLogRecordProcessor {
  forceFlush() {
    return Promise.resolve();
  }
  onEmit(_logRecord, _context) {}
  shutdown() {
    return Promise.resolve();
  }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Implementation of the {@link LogRecordProcessor} that simply forwards all
 * received events to a list of {@link LogRecordProcessor}s.
 */
class MultiLogRecordProcessor {
  processors;
  forceFlushTimeoutMillis;
  constructor(processors, forceFlushTimeoutMillis) {
    this.processors = processors;
    this.forceFlushTimeoutMillis = forceFlushTimeoutMillis;
  }
  async forceFlush() {
    const timeout = this.forceFlushTimeoutMillis;
    await Promise.all(this.processors.map(processor => core.callWithTimeout(processor.forceFlush(), timeout)));
  }
  onEmit(logRecord, context) {
    this.processors.forEach(processors => processors.onEmit(logRecord, context));
  }
  async shutdown() {
    await Promise.all(this.processors.map(processor => processor.shutdown()));
  }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class LoggerProviderSharedState {
  resource;
  forceFlushTimeoutMillis;
  logRecordLimits;
  processors;
  loggers = new Map();
  activeProcessor;
  registeredLogRecordProcessors = [];
  constructor(resource, forceFlushTimeoutMillis, logRecordLimits, processors) {
    this.resource = resource;
    this.forceFlushTimeoutMillis = forceFlushTimeoutMillis;
    this.logRecordLimits = logRecordLimits;
    this.processors = processors;
    if (processors.length > 0) {
      this.registeredLogRecordProcessors = processors;
      this.activeProcessor = new MultiLogRecordProcessor(this.registeredLogRecordProcessors, this.forceFlushTimeoutMillis);
    } else {
      this.activeProcessor = new NoopLogRecordProcessor();
    }
  }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DEFAULT_LOGGER_NAME = 'unknown';
class LoggerProvider {
  _shutdownOnce;
  _sharedState;
  constructor(config = {}) {
    const mergedConfig = core.merge({}, loadDefaultConfig(), config);
    const resource = config.resource ?? resources.defaultResource();
    this._sharedState = new LoggerProviderSharedState(resource, mergedConfig.forceFlushTimeoutMillis, reconfigureLimits(mergedConfig.logRecordLimits), config?.processors ?? []);
    this._shutdownOnce = new core.BindOnceFuture(this._shutdown, this);
  }
  /**
   * Get a logger with the configuration of the LoggerProvider.
   */
  getLogger(name, version, options) {
    if (this._shutdownOnce.isCalled) {
      api.diag.warn('A shutdown LoggerProvider cannot provide a Logger');
      return NOOP_LOGGER;
    }
    if (!name) {
      api.diag.warn('Logger requested without instrumentation scope name.');
    }
    const loggerName = name || DEFAULT_LOGGER_NAME;
    const key = `${loggerName}@${version || ''}:${options?.schemaUrl || ''}`;
    if (!this._sharedState.loggers.has(key)) {
      this._sharedState.loggers.set(key, new Logger({
        name: loggerName,
        version,
        schemaUrl: options?.schemaUrl
      }, this._sharedState));
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this._sharedState.loggers.get(key);
  }
  /**
   * Notifies all registered LogRecordProcessor to flush any buffered data.
   *
   * Returns a promise which is resolved when all flushes are complete.
   */
  forceFlush() {
    // do not flush after shutdown
    if (this._shutdownOnce.isCalled) {
      api.diag.warn('invalid attempt to force flush after LoggerProvider shutdown');
      return this._shutdownOnce.promise;
    }
    return this._sharedState.activeProcessor.forceFlush();
  }
  /**
   * Flush all buffered data and shut down the LoggerProvider and all registered
   * LogRecordProcessor.
   *
   * Returns a promise which is resolved when all flushes are complete.
   */
  shutdown() {
    if (this._shutdownOnce.isCalled) {
      api.diag.warn('shutdown may only be called once per LoggerProvider');
      return this._shutdownOnce.promise;
    }
    return this._shutdownOnce.call();
  }
  _shutdown() {
    return this._sharedState.activeProcessor.shutdown();
  }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This is implementation of {@link LogRecordExporter} that prints LogRecords to the
 * console. This class can be used for diagnostic purposes.
 *
 * NOTE: This {@link LogRecordExporter} is intended for diagnostics use only, output rendered to the console may change at any time.
 */
/* eslint-disable no-console */
class ConsoleLogRecordExporter {
  /**
   * Export logs.
   * @param logs
   * @param resultCallback
   */
  export(logs, resultCallback) {
    this._sendLogRecords(logs, resultCallback);
  }
  /**
   * Shutdown the exporter.
   */
  shutdown() {
    return Promise.resolve();
  }
  /**
   * converts logRecord info into more readable format
   * @param logRecord
   */
  _exportInfo(logRecord) {
    return {
      resource: {
        attributes: logRecord.resource.attributes
      },
      instrumentationScope: logRecord.instrumentationScope,
      timestamp: core.hrTimeToMicroseconds(logRecord.hrTime),
      traceId: logRecord.spanContext?.traceId,
      spanId: logRecord.spanContext?.spanId,
      traceFlags: logRecord.spanContext?.traceFlags,
      severityText: logRecord.severityText,
      severityNumber: logRecord.severityNumber,
      body: logRecord.body,
      attributes: logRecord.attributes
    };
  }
  /**
   * Showing logs  in console
   * @param logRecords
   * @param done
   */
  _sendLogRecords(logRecords, done) {
    for (const logRecord of logRecords) {
      console.dir(this._exportInfo(logRecord), {
        depth: 3
      });
    }
    done?.({
      code: core.ExportResultCode.SUCCESS
    });
  }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class SimpleLogRecordProcessor {
  _exporter;
  _shutdownOnce;
  _unresolvedExports;
  constructor(_exporter) {
    this._exporter = _exporter;
    this._shutdownOnce = new core.BindOnceFuture(this._shutdown, this);
    this._unresolvedExports = new Set();
  }
  onEmit(logRecord) {
    if (this._shutdownOnce.isCalled) {
      return;
    }
    const doExport = () => core.internal._export(this._exporter, [logRecord]).then(result => {
      if (result.code !== core.ExportResultCode.SUCCESS) {
        core.globalErrorHandler(result.error ?? new Error(`SimpleLogRecordProcessor: log record export failed (status ${result})`));
      }
    }).catch(core.globalErrorHandler);
    // Avoid scheduling a promise to make the behavior more predictable and easier to test
    if (logRecord.resource.asyncAttributesPending) {
      const exportPromise = logRecord.resource.waitForAsyncAttributes?.().then(() => {
        // Using TS Non-null assertion operator because exportPromise could not be null in here
        // if waitForAsyncAttributes is not present this code will never be reached
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this._unresolvedExports.delete(exportPromise);
        return doExport();
      }, core.globalErrorHandler);
      // store the unresolved exports
      if (exportPromise != null) {
        this._unresolvedExports.add(exportPromise);
      }
    } else {
      void doExport();
    }
  }
  async forceFlush() {
    // await unresolved resources before resolving
    await Promise.all(Array.from(this._unresolvedExports));
  }
  shutdown() {
    return this._shutdownOnce.call();
  }
  _shutdown() {
    return this._exporter.shutdown();
  }
}

// This code will eventually be packaged upstream into a WebSDK package.
// Once it is released as a package, this distro will depend directly on the upstream package.
// https://github.com/open-telemetry/opentelemetry-js/pull/4325
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** This class represents everything needed to register a fully configured OpenTelemetry Web SDK */
class WebSDK {
  /**
   * Create a new Web SDK instance
   */
  constructor(configuration = {}) {
    var _a, _b, _c;
    // As of v2 of the JS packages, we need to explicitly start with the default resource that contains
    // telemetry.sdk.language etc.
    this._resource = resources.defaultResource().merge((_a = configuration.resource) !== null && _a !== void 0 ? _a : resources.resourceFromAttributes({}));
    this._resourceDetectors = (_b = configuration.resourceDetectors) !== null && _b !== void 0 ? _b : [opentelemetryBrowserDetector.browserDetector];
    this._serviceName = configuration.serviceName;
    this._serviceVersion = configuration.serviceVersion;
    this._autoDetectResources = (_c = configuration.autoDetectResources) !== null && _c !== void 0 ? _c : true;
    if (configuration.spanProcessor || configuration.traceExporter || configuration.spanProcessors) {
      const tracerProviderConfig = {};
      if (configuration.sampler) {
        tracerProviderConfig.sampler = configuration.sampler;
      }
      if (configuration.spanLimits) {
        tracerProviderConfig.spanLimits = configuration.spanLimits;
      }
      if (configuration.idGenerator) {
        tracerProviderConfig.idGenerator = configuration.idGenerator;
      }
      const spanProcessors = configuration.spanProcessors || [];
      if (configuration.traceExporter) {
        spanProcessors.push(new sdkTraceBase.BatchSpanProcessor(configuration.traceExporter));
      }
      this._tracerProviderConfig = {
        tracerConfig: tracerProviderConfig,
        spanProcessor: configuration.spanProcessor,
        spanProcessors: spanProcessors,
        contextManager: configuration.contextManager,
        textMapPropagator: configuration.textMapPropagator
      };
    }
    if (configuration.metricExporters) {
      this._meterProviderConfig = {
        metricExporters: configuration.metricExporters
      };
    }
    if (configuration.logExporters) {
      this._loggerProviderConfig = {
        logExporters: configuration.logExporters
      };
    }
    let instrumentations = [];
    if (configuration.instrumentations) {
      instrumentations = configuration.instrumentations;
    }
    this._instrumentations = instrumentations;
  }
  /**
   * Call this method to construct SDK components and register them with the OpenTelemetry API.
   */
  start() {
    var _a, _b, _c, _d, _e;
    if (this._disabled) {
      return;
    }
    if (this._autoDetectResources) {
      const internalConfig = {
        detectors: this._resourceDetectors
      };
      this._resource = this._resource.merge(resources.detectResources(internalConfig));
    }
    this._resource = this._serviceName === undefined ? this._resource : this._resource.merge(resources.resourceFromAttributes({
      [semanticConventions.ATTR_SERVICE_NAME]: this._serviceName
    }));
    if (this._serviceVersion !== undefined) {
      this._resource = this._resource.merge(resources.resourceFromAttributes({
        [semanticConventions.ATTR_SERVICE_VERSION]: this._serviceVersion
      }));
    }
    const spanProcessors = [];
    if ((_a = this._tracerProviderConfig) === null || _a === void 0 ? void 0 : _a.spanProcessor) {
      spanProcessors.push(this._tracerProviderConfig.spanProcessor);
    }
    if ((_b = this._tracerProviderConfig) === null || _b === void 0 ? void 0 : _b.spanProcessors) {
      spanProcessors.push(...this._tracerProviderConfig.spanProcessors);
    }
    const tracerProvider = new sdkTraceWeb.WebTracerProvider(Object.assign(Object.assign({}, (_c = this._tracerProviderConfig) === null || _c === void 0 ? void 0 : _c.tracerConfig), {
      resource: this._resource,
      spanProcessors: spanProcessors
    }));
    this._tracerProvider = tracerProvider;
    tracerProvider.register({
      contextManager: (_d = this._tracerProviderConfig) === null || _d === void 0 ? void 0 : _d.contextManager,
      propagator: (_e = this._tracerProviderConfig) === null || _e === void 0 ? void 0 : _e.textMapPropagator
    });
    if (this._meterProviderConfig) {
      const readers = this._meterProviderConfig.metricExporters.map(exporter => {
        return new PeriodicExportingMetricReader({
          exporter
        });
      });
      this._meterProvider = new MeterProvider({
        resource: this._resource,
        readers
      });
      api.metrics.setGlobalMeterProvider(this._meterProvider);
    }
    if (this._loggerProviderConfig) {
      const processors = this._loggerProviderConfig.logExporters.map(exporter => {
        return new SimpleLogRecordProcessor(exporter);
      });
      this._loggerProvider = new LoggerProvider({
        resource: this._resource,
        processors
      });
      logs.setGlobalLoggerProvider(this._loggerProvider);
    }
    instrumentation.registerInstrumentations({
      instrumentations: this._instrumentations
    });
  }
  /* Experimental getter method: not currently part of the upstream
   * sdk's API */
  getResourceAttributes() {
    return this._resource.attributes;
  }
  forceFlush() {
    const promises = [];
    if (this._tracerProvider) {
      promises.push(this._tracerProvider.forceFlush());
    }
    if (this._meterProvider) {
      promises.push(this._meterProvider.forceFlush());
    }
    if (this._loggerProvider) {
      promises.push(this._loggerProvider.forceFlush());
    }
    return Promise.all(promises)
    // return void instead of the array from Promise.all
    .then(() => {});
  }
  shutdown() {
    const promises = [];
    if (this._tracerProvider) {
      promises.push(this._tracerProvider.shutdown());
    }
    if (this._meterProvider) {
      promises.push(this._meterProvider.shutdown());
    }
    if (this._loggerProvider) {
      promises.push(this._loggerProvider.shutdown());
    }
    return Promise.all(promises)
    // return void instead of the array from Promise.all
    .then(() => {});
  }
}

// Constants
const DEFAULT_API_ENDPOINT = 'https://api.honeycomb.io';
const TRACES_PATH = 'v1/traces';
const DEFAULT_TRACES_ENDPOINT = `${DEFAULT_API_ENDPOINT}/${TRACES_PATH}`;
const METRICS_PATH = 'v1/metrics';
const DEFAULT_METRICS_ENDPOINT = `${DEFAULT_API_ENDPOINT}/${METRICS_PATH}`;
const LOGS_PATH = 'v1/logs';
const DEFAULT_LOGS_ENDPOINT = `${DEFAULT_API_ENDPOINT}/${LOGS_PATH}`;
const DEFAULT_SERVICE_NAME = 'unknown_service';
const DEFAULT_SAMPLE_RATE = 1;
/**
 * Default options for the Honeycomb Web SDK.
 */
const defaultOptions = {
  apiKey: '',
  tracesApiKey: '',
  endpoint: DEFAULT_TRACES_ENDPOINT,
  tracesEndpoint: DEFAULT_TRACES_ENDPOINT,
  serviceName: DEFAULT_SERVICE_NAME,
  debug: false,
  sampleRate: 1,
  skipOptionsValidation: false,
  localVisualizations: false,
  webVitalsInstrumentationConfig: {
    enabled: true
  }
};
const createHoneycombSDKLogMessage = message => `@honeycombio/opentelemetry-web: ${message}`;
const classicKeyRegex = /^[a-f0-9]*$/;
const ingestClassicKeyRegex = /^hc[a-z]ic_[a-z0-9]*$/;
/**
 * Determines whether the passed in apikey is classic or not.
 *
 * @param apikey the apikey
 * @returns a boolean to indicate if the apikey was a classic key
 */
function isClassic(apikey) {
  if (apikey == null || apikey.length === 0) {
    return false;
  } else if (apikey.length === 32) {
    return classicKeyRegex.test(apikey);
  } else if (apikey.length === 64) {
    return ingestClassicKeyRegex.test(apikey);
  }
  return false;
}
/**
 * Checks for and appends v1/{traces, metrics, logs} to provided URL if missing
 * when using an HTTP based exporter protocol.
 *
 * @param url the base URL to append traces path to if missing
 * @returns the endpoint with traces path appended if missing
 */
function maybeAppendPath(url, path) {
  if (url.endsWith(path) || url.endsWith(`${path}/`)) {
    return url;
  }
  return url.endsWith('/') ? url + path : url + '/' + path;
}
const getTracesEndpoint = options => {
  // use `tracesEndpoint` option unchanged if provided
  if (options === null || options === void 0 ? void 0 : options.tracesEndpoint) {
    return options.tracesEndpoint;
  }
  // use `endpoint` option if provided and append '/v1/traces' if not already appended
  if (options === null || options === void 0 ? void 0 : options.endpoint) {
    return maybeAppendPath(options.endpoint, TRACES_PATH);
  }
  return DEFAULT_TRACES_ENDPOINT;
};
const getMetricsEndpoint = options => {
  // use `metricsEndpoint` option unchanged if provided
  if (options === null || options === void 0 ? void 0 : options.metricsEndpoint) {
    return options.metricsEndpoint;
  }
  // use `endpoint` option if provided and append '/v1/metrics' if not already appended
  if (options === null || options === void 0 ? void 0 : options.endpoint) {
    return maybeAppendPath(options.endpoint, METRICS_PATH);
  }
  return DEFAULT_METRICS_ENDPOINT;
};
const getLogsEndpoint = options => {
  // use `logsEndpoint` option unchanged if provided
  if (options === null || options === void 0 ? void 0 : options.logsEndpoint) {
    return options.logsEndpoint;
  }
  // use `endpoint` option if provided and append '/v1/logs' if not already appended
  if (options === null || options === void 0 ? void 0 : options.endpoint) {
    return maybeAppendPath(options.endpoint, LOGS_PATH);
  }
  return DEFAULT_LOGS_ENDPOINT;
};
const getTracesApiKey = options => {
  return (options === null || options === void 0 ? void 0 : options.tracesApiKey) || (options === null || options === void 0 ? void 0 : options.apiKey);
};
const getMetricsApiKey = options => {
  return (options === null || options === void 0 ? void 0 : options.metricsApiKey) || (options === null || options === void 0 ? void 0 : options.apiKey);
};
const getLogsApiKey = options => {
  return (options === null || options === void 0 ? void 0 : options.logsApiKey) || (options === null || options === void 0 ? void 0 : options.apiKey);
};
const getSampleRate = options => {
  if (
  // must be a whole positive integer
  typeof (options === null || options === void 0 ? void 0 : options.sampleRate) === 'number' && Number.isSafeInteger(options === null || options === void 0 ? void 0 : options.sampleRate) && (options === null || options === void 0 ? void 0 : options.sampleRate) >= 0) {
    return options === null || options === void 0 ? void 0 : options.sampleRate;
  }
  return DEFAULT_SAMPLE_RATE;
};

const MISSING_API_KEY_ERROR = createHoneycombSDKLogMessage('❌ Missing API Key. Set `apiKey` in HoneycombOptions. Telemetry will not be exported.');
const MISSING_SERVICE_NAME_ERROR = createHoneycombSDKLogMessage(`❌ Missing Service Name. Set \`serviceName\` in HoneycombOptions. Defaulting to '${defaultOptions.serviceName}'`);
const IGNORED_DATASET_ERROR = createHoneycombSDKLogMessage('🔕 Dataset is ignored in favor of service name.');
const MISSING_DATASET_ERROR = createHoneycombSDKLogMessage('❌ Missing dataset. Specify either HONEYCOMB_DATASET environment variable or dataset in the options parameter.');
const SKIPPING_OPTIONS_VALIDATION_MSG = createHoneycombSDKLogMessage('⏭️ Skipping options validation. To re-enable, set skipOptionsValidation option or HONEYCOMB_SKIP_OPTIONS_VALIDATION to false.');
const CUSTOM_COLLECTOR_VALIDATION_MSG = createHoneycombSDKLogMessage('⏭️ Skipping options validation, because a custom collector is being used.');
const SAMPLER_OVERRIDE_WARNING = createHoneycombSDKLogMessage('🔨 Default deterministic sampler has been overridden. Honeycomb requires a resource attribute called SampleRate to properly show weighted values. Non-deterministic sampleRate could lead to missing spans in Honeycomb. See our docs for more details. https://docs.honeycomb.io/getting-data-in/opentelemetry/node-distro/#sampling-without-the-honeycomb-sdk');
const MISSING_FIELDS_FOR_LOCAL_VISUALIZATIONS = createHoneycombSDKLogMessage('🔕 Disabling local visualizations - must have both service name and API key configured.');
const MISSING_FIELDS_FOR_GENERATING_LINKS = createHoneycombSDKLogMessage('🔕 Disabling local visualizations - cannot infer auth and ui url roots from endpoint url.');
const FAILED_AUTH_FOR_LOCAL_VISUALIZATIONS = createHoneycombSDKLogMessage('🔕 Failed to get proper auth response from Honeycomb. No local visualization available.');
const NO_EXPORTERS_DISABLED_DEFAULT = createHoneycombSDKLogMessage('🔕 Default honeycomb exporter disabled but no exporters provided');
/**
 * Returns true iff the endpoint is *not* a Honeycomb endpoint, such as api.honeycomb.io or
 * api.eu1.honeycomb.io.
 */
const isCustomCollector = endpoint => {
  try {
    const url = new URL(endpoint);
    return !url.hostname.endsWith('.honeycomb.io');
  } catch (_a) {
    // If URL.parse fails, assume this isn't a custom collector,
    // so that normal options validation happens.
    return false;
  }
};
const validateOptionsWarnings = options => {
  var _a, _b;
  const logLevel = (options === null || options === void 0 ? void 0 : options.logLevel) ? options.logLevel : api.DiagLogLevel.DEBUG;
  if (options === null || options === void 0 ? void 0 : options.skipOptionsValidation) {
    if (logLevel >= api.DiagLogLevel.DEBUG) {
      console.debug(SKIPPING_OPTIONS_VALIDATION_MSG);
    }
    return;
  }
  const endpoint = (_a = options === null || options === void 0 ? void 0 : options.tracesEndpoint) !== null && _a !== void 0 ? _a : options === null || options === void 0 ? void 0 : options.endpoint;
  if (endpoint && isCustomCollector(endpoint)) {
    if (logLevel >= api.DiagLogLevel.DEBUG) {
      console.debug(CUSTOM_COLLECTOR_VALIDATION_MSG);
    }
    return;
  }
  // warn if api key is missing
  if (!(options === null || options === void 0 ? void 0 : options.apiKey) && logLevel >= api.DiagLogLevel.WARN) {
    console.warn(MISSING_API_KEY_ERROR);
  }
  // warn if service name is missing
  if (!(options === null || options === void 0 ? void 0 : options.serviceName) && logLevel >= api.DiagLogLevel.WARN) {
    console.warn(MISSING_SERVICE_NAME_ERROR);
  }
  // warn if dataset is set while using an environment-aware key
  if ((options === null || options === void 0 ? void 0 : options.apiKey) && !isClassic(options === null || options === void 0 ? void 0 : options.apiKey) && (options === null || options === void 0 ? void 0 : options.dataset) && logLevel >= api.DiagLogLevel.WARN) {
    console.warn(IGNORED_DATASET_ERROR);
  }
  // warn if dataset is missing if using classic key
  if ((options === null || options === void 0 ? void 0 : options.apiKey) && isClassic(options === null || options === void 0 ? void 0 : options.apiKey) && !(options === null || options === void 0 ? void 0 : options.dataset) && logLevel >= api.DiagLogLevel.WARN) {
    console.warn(MISSING_DATASET_ERROR);
  }
  // warn if custom sampler provided
  if ((options === null || options === void 0 ? void 0 : options.sampler) && logLevel >= api.DiagLogLevel.DEBUG) {
    console.debug(SAMPLER_OVERRIDE_WARNING);
  }
  // warn if no exporter will be set
  if ((options === null || options === void 0 ? void 0 : options.disableDefaultTraceExporter) === true && !(options === null || options === void 0 ? void 0 : options.traceExporter) && !((_b = options === null || options === void 0 ? void 0 : options.traceExporters) === null || _b === void 0 ? void 0 : _b.length)) {
    console.warn(NO_EXPORTERS_DISABLED_DEFAULT);
  }
  return options;
};

/**
 * Configures the Honeycomb Web SDK to log debug information to the console.
 * Enables the DiagConsoleLogger and sets the log level to DEBUG.
 * Logs the provided Honeycomb options to the console, as well as defaults.
 *
 * @param options the provided Honeycomb options
 */
function configureDebug(options) {
  if (!(options === null || options === void 0 ? void 0 : options.debug)) {
    return;
  }
  api.diag.setLogger(new api.DiagConsoleLogger(), api.DiagLogLevel.DEBUG);
  api.diag.debug(createHoneycombSDKLogMessage('🐝 Honeycomb Web SDK Debug Mode Enabled 🐝'));
  // traces endpoint must be computed from provided options
  const tracesEndpoint = getTracesEndpoint(options);
  const currentOptions = Object.assign(Object.assign(Object.assign({}, defaultOptions), options), {
    tracesEndpoint
  });
  debugTracesApiKey(currentOptions);
  debugServiceName(currentOptions);
  debugTracesEndpoint(currentOptions);
  debugSampleRate(currentOptions);
}
function debugTracesApiKey(options) {
  const tracesApiKey = getTracesApiKey(options) || '';
  if (!tracesApiKey) {
    api.diag.debug(MISSING_API_KEY_ERROR);
    return;
  }
  api.diag.debug(createHoneycombSDKLogMessage(`API Key configured for traces: '${tracesApiKey}'`));
}
function debugServiceName(options) {
  const serviceName = options.serviceName || defaultOptions.serviceName;
  if (serviceName === defaultOptions.serviceName) {
    api.diag.debug(MISSING_SERVICE_NAME_ERROR);
    return;
  }
  api.diag.debug(`@honeycombio/opentelemetry-web: Service Name configured for traces: '${serviceName}'`);
}
function debugTracesEndpoint(options) {
  const tracesEndpoint = getTracesEndpoint(options);
  if (!tracesEndpoint) {
    api.diag.debug(createHoneycombSDKLogMessage('No endpoint configured for traces'));
    return;
  }
  api.diag.debug(createHoneycombSDKLogMessage(`Endpoint configured for traces: '${tracesEndpoint}'`));
}
function debugSampleRate(options) {
  const sampleRate = getSampleRate(options);
  if (!sampleRate) {
    // this should never happen, but guard just in case?
    api.diag.debug('No sampler configured for traces');
    return;
  }
  api.diag.debug(createHoneycombSDKLogMessage(`Sample Rate configured for traces: '${sampleRate}'`));
}

/**
 * Builds and returns a Deterministic Sampler that uses the provided sample rate to
 * configure the inner sampler, if custom sampler has not provided.
 * @param options The {@link HoneycombOptions}
 * @returns a {@link DeterministicSampler}
 */
const configureSampler = options => {
  if (options === null || options === void 0 ? void 0 : options.sampler) {
    return options.sampler;
  }
  const sampleRate = getSampleRate(options);
  return new DeterministicSampler(sampleRate);
};
/**
 * A {@link Sampler} that uses a deterministic sample rate to configure the sampler.
 */
class DeterministicSampler {
  constructor(sampleRate) {
    this._sampleRate = sampleRate;
    switch (sampleRate) {
      // sample rate of 0 means send nothing
      case 0:
        this._sampler = new sdkTraceBase.AlwaysOffSampler();
        break;
      // sample rate of 1 is default, send everything
      case 1:
        this._sampler = new sdkTraceBase.AlwaysOnSampler();
        break;
      default:
        {
          const ratio = 1.0 / sampleRate;
          this._sampler = new sdkTraceBase.TraceIdRatioBasedSampler(ratio);
          break;
        }
    }
  }
  shouldSample(context, traceId, spanName, spanKind, attributes, links) {
    const result = this._sampler.shouldSample(context, traceId, spanName, spanKind, attributes, links);
    return Object.assign(Object.assign({}, result), {
      attributes: Object.assign(Object.assign({}, result.attributes), {
        SampleRate: this._sampleRate
      })
    });
  }
  toString() {
    return `DeterministicSampler(${this._sampler.toString()})`;
  }
}

class t {
  t;
  o = 0;
  i = [];
  u(t) {
    if (t.hadRecentInput) return;
    const e = this.i[0],
      n = this.i.at(-1);
    this.o && e && n && t.startTime - n.startTime < 1e3 && t.startTime - e.startTime < 5e3 ? (this.o += t.value, this.i.push(t)) : (this.o = t.value, this.i = [t]), this.t?.(t);
  }
}
const e = () => {
    const t = performance.getEntriesByType("navigation")[0];
    if (t && t.responseStart > 0 && t.responseStart < performance.now()) return t;
  },
  n = t => {
    if ("loading" === document.readyState) return "loading";
    {
      const n = e();
      if (n) {
        if (t < n.domInteractive) return "loading";
        if (0 === n.domContentLoadedEventStart || t < n.domContentLoadedEventStart) return "dom-interactive";
        if (0 === n.domComplete || t < n.domComplete) return "dom-content-loaded";
      }
    }
    return "complete";
  },
  o = t => {
    const e = t.nodeName;
    return 1 === t.nodeType ? e.toLowerCase() : e.toUpperCase().replace(/^#/, "");
  },
  i = t => {
    let e = "";
    try {
      for (; 9 !== t?.nodeType;) {
        const n = t,
          i = n.id ? "#" + n.id : [o(n), ...Array.from(n.classList).sort()].join(".");
        if (e.length + i.length > 99) return e || i;
        if (e = e ? i + ">" + e : i, n.id) break;
        t = n.parentNode;
      }
    } catch {}
    return e;
  },
  r = new WeakMap();
function s(t, e) {
  return r.get(t) || r.set(t, new e()), r.get(t);
}
let a = -1;
const c = () => a,
  u = t => {
    addEventListener("pageshow", e => {
      e.persisted && (a = e.timeStamp, t(e));
    }, true);
  },
  d = (t, e, n, o) => {
    let i, r;
    return s => {
      e.value >= 0 && (s || o) && (r = e.value - (i ?? 0), (r || void 0 === i) && (i = e.value, e.delta = r, e.rating = ((t, e) => t > e[1] ? "poor" : t > e[0] ? "needs-improvement" : "good")(e.value, n), t(e)));
    };
  },
  f = t => {
    requestAnimationFrame(() => requestAnimationFrame(() => t()));
  },
  l = () => {
    const t = e();
    return t?.activationStart ?? 0;
  },
  h = (t, n = -1) => {
    const o = e();
    let i = "navigate";
    c() >= 0 ? i = "back-forward-cache" : o && (document.prerendering || l() > 0 ? i = "prerender" : document.wasDiscarded ? i = "restore" : o.type && (i = o.type.replace(/_/g, "-")));
    return {
      name: t,
      value: n,
      rating: "good",
      delta: 0,
      entries: [],
      id: `v5-${Date.now()}-${Math.floor(8999999999999 * Math.random()) + 1e12}`,
      navigationType: i
    };
  },
  m = (t, e, n = {}) => {
    try {
      if (PerformanceObserver.supportedEntryTypes.includes(t)) {
        const o = new PerformanceObserver(t => {
          Promise.resolve().then(() => {
            e(t.getEntries());
          });
        });
        return o.observe({
          type: t,
          buffered: !0,
          ...n
        }), o;
      }
    } catch {}
  },
  g = t => {
    let e = false;
    return () => {
      e || (t(), e = true);
    };
  };
let p = -1;
const y = () => "hidden" !== document.visibilityState || document.prerendering ? 1 / 0 : 0,
  v = t => {
    "hidden" === document.visibilityState && p > -1 && (p = "visibilitychange" === t.type ? t.timeStamp : 0, M());
  },
  b = () => {
    addEventListener("visibilitychange", v, true), addEventListener("prerenderingchange", v, true);
  },
  M = () => {
    removeEventListener("visibilitychange", v, true), removeEventListener("prerenderingchange", v, true);
  },
  T = () => {
    if (p < 0) {
      const t = l(),
        e = document.prerendering ? void 0 : globalThis.performance.getEntriesByType("visibility-state").filter(e => "hidden" === e.name && e.startTime > t)[0]?.startTime;
      p = e ?? y(), b(), u(() => {
        setTimeout(() => {
          p = y(), b();
        });
      });
    }
    return {
      get firstHiddenTime() {
        return p;
      }
    };
  },
  D = t => {
    document.prerendering ? addEventListener("prerenderingchange", () => t(), true) : t();
  },
  E = [1800, 3e3],
  P = (t, e = {}) => {
    D(() => {
      const n = T();
      let o,
        i = h("FCP");
      const r = m("paint", t => {
        for (const e of t) "first-contentful-paint" === e.name && (r.disconnect(), e.startTime < n.firstHiddenTime && (i.value = Math.max(e.startTime - l(), 0), i.entries.push(e), o(true)));
      });
      r && (o = d(t, i, E, e.reportAllChanges), u(n => {
        i = h("FCP"), o = d(t, i, E, e.reportAllChanges), f(() => {
          i.value = performance.now() - n.timeStamp, o(true);
        });
      }));
    });
  },
  L = [.1, .25],
  S = t => t.find(t => 1 === t.node?.nodeType) || t[0],
  _ = (e, o = {}) => {
    const r = s(o = Object.assign({}, o), t),
      a = new WeakMap();
    r.t = t => {
      if (t?.sources?.length) {
        const e = S(t.sources);
        if (e) {
          const t = (o.generateTarget ?? i)(e.node);
          a.set(e, t);
        }
      }
    };
    ((e, n = {}) => {
      P(g(() => {
        let o,
          i = h("CLS", 0);
        const r = s(n, t),
          a = t => {
            for (const e of t) r.u(e);
            r.o > i.value && (i.value = r.o, i.entries = r.i, o());
          },
          c = m("layout-shift", a);
        c && (o = d(e, i, L, n.reportAllChanges), document.addEventListener("visibilitychange", () => {
          "hidden" === document.visibilityState && (a(c.takeRecords()), o(true));
        }), u(() => {
          r.o = 0, i = h("CLS", 0), o = d(e, i, L, n.reportAllChanges), f(() => o());
        }), setTimeout(o));
      }));
    })(t => {
      const o = (t => {
        let e = {};
        if (t.entries.length) {
          const o = t.entries.reduce((t, e) => t.value > e.value ? t : e);
          if (o?.sources?.length) {
            const t = S(o.sources);
            t && (e = {
              largestShiftTarget: a.get(t),
              largestShiftTime: o.startTime,
              largestShiftValue: o.value,
              largestShiftSource: t,
              largestShiftEntry: o,
              loadState: n(o.startTime)
            });
          }
        }
        return Object.assign(t, {
          attribution: e
        });
      })(t);
      e(o);
    }, o);
  },
  w = (t, o = {}) => {
    P(o => {
      const i = (t => {
        let o = {
          timeToFirstByte: 0,
          firstByteToFCP: t.value,
          loadState: n(c())
        };
        if (t.entries.length) {
          const i = e(),
            r = t.entries.at(-1);
          if (i) {
            const e = i.activationStart || 0,
              s = Math.max(0, i.responseStart - e);
            o = {
              timeToFirstByte: s,
              firstByteToFCP: t.value - s,
              loadState: n(t.entries[0].startTime),
              navigationEntry: i,
              fcpEntry: r
            };
          }
        }
        return Object.assign(t, {
          attribution: o
        });
      })(o);
      t(i);
    }, o);
  };
let k = 0,
  F = 1 / 0,
  B = 0;
const C = t => {
  for (const e of t) e.interactionId && (F = Math.min(F, e.interactionId), B = Math.max(B, e.interactionId), k = B ? (B - F) / 7 + 1 : 0);
};
let O;
const j = () => O ? k : performance.interactionCount ?? 0,
  I = () => {
    "interactionCount" in performance || O || (O = m("event", C, {
      type: "event",
      buffered: true,
      durationThreshold: 0
    }));
  };
let A = 0;
class W {
  l = [];
  h = new Map();
  m;
  p;
  v() {
    A = j(), this.l.length = 0, this.h.clear();
  }
  M() {
    const t = Math.min(this.l.length - 1, Math.floor((j() - A) / 50));
    return this.l[t];
  }
  u(t) {
    if (this.m?.(t), !t.interactionId && "first-input" !== t.entryType) return;
    const e = this.l.at(-1);
    let n = this.h.get(t.interactionId);
    if (n || this.l.length < 10 || t.duration > e.T) {
      if (n ? t.duration > n.T ? (n.entries = [t], n.T = t.duration) : t.duration === n.T && t.startTime === n.entries[0].startTime && n.entries.push(t) : (n = {
        id: t.interactionId,
        entries: [t],
        T: t.duration
      }, this.h.set(n.id, n), this.l.push(n)), this.l.sort((t, e) => e.T - t.T), this.l.length > 10) {
        const t = this.l.splice(10);
        for (const e of t) this.h.delete(e.id);
      }
      this.p?.(n);
    }
  }
}
const q = t => {
    const e = globalThis.requestIdleCallback || setTimeout;
    "hidden" === document.visibilityState ? t() : (t = g(t), document.addEventListener("visibilitychange", t, {
      once: true
    }), e(() => {
      t(), document.removeEventListener("visibilitychange", t);
    }));
  },
  x = [200, 500],
  N = (t, e = {}) => {
    const o = s(e = Object.assign({}, e), W);
    let r = [],
      a = [],
      c = 0;
    const f = new WeakMap(),
      l = new WeakMap();
    let g = false;
    const p = () => {
        g || (q(y), g = true);
      },
      y = () => {
        const t = o.l.map(t => f.get(t.entries[0])),
          e = a.length - 50;
        a = a.filter((n, o) => o >= e || t.includes(n));
        const n = new Set();
        for (const t of a) {
          const e = v(t.startTime, t.processingEnd);
          for (const t of e) n.add(t);
        }
        const i = r.length - 1 - 50;
        r = r.filter((t, e) => t.startTime > c && e > i || n.has(t)), g = false;
      };
    o.m = t => {
      const e = t.startTime + t.duration;
      let n;
      c = Math.max(c, t.processingEnd);
      for (let o = a.length - 1; o >= 0; o--) {
        const i = a[o];
        if (Math.abs(e - i.renderTime) <= 8) {
          n = i, n.startTime = Math.min(t.startTime, n.startTime), n.processingStart = Math.min(t.processingStart, n.processingStart), n.processingEnd = Math.max(t.processingEnd, n.processingEnd), n.entries.push(t);
          break;
        }
      }
      n || (n = {
        startTime: t.startTime,
        processingStart: t.processingStart,
        processingEnd: t.processingEnd,
        renderTime: e,
        entries: [t]
      }, a.push(n)), (t.interactionId || "first-input" === t.entryType) && f.set(t, n), p();
    }, o.p = t => {
      if (!l.get(t)) {
        const n = (e.generateTarget ?? i)(t.entries[0].target);
        l.set(t, n);
      }
    };
    const v = (t, e) => {
        const n = [];
        for (const o of r) if (!(o.startTime + o.duration < t)) {
          if (o.startTime > e) break;
          n.push(o);
        }
        return n;
      },
      b = t => {
        const e = t.entries[0],
          i = f.get(e),
          r = e.processingStart,
          s = Math.max(e.startTime + e.duration, r),
          a = Math.min(i.processingEnd, s),
          c = i.entries.sort((t, e) => t.processingStart - e.processingStart),
          u = v(e.startTime, a),
          d = o.h.get(e.interactionId),
          h = {
            interactionTarget: l.get(d),
            interactionType: e.name.startsWith("key") ? "keyboard" : "pointer",
            interactionTime: e.startTime,
            nextPaintTime: s,
            processedEventEntries: c,
            longAnimationFrameEntries: u,
            inputDelay: r - e.startTime,
            processingDuration: a - r,
            presentationDelay: s - a,
            loadState: n(e.startTime),
            longestScript: void 0,
            totalScriptDuration: void 0,
            totalStyleAndLayoutDuration: void 0,
            totalPaintDuration: void 0,
            totalUnattributedDuration: void 0
          };
        (t => {
          if (!t.longAnimationFrameEntries?.length) return;
          const e = t.interactionTime,
            n = t.inputDelay,
            o = t.processingDuration;
          let i,
            r,
            s = 0,
            a = 0,
            c = 0,
            u = 0;
          for (const c of t.longAnimationFrameEntries) {
            a = a + c.startTime + c.duration - c.styleAndLayoutStart;
            for (const t of c.scripts) {
              const c = t.startTime + t.duration;
              if (c < e) continue;
              const d = c - Math.max(e, t.startTime),
                f = t.duration ? d / t.duration * t.forcedStyleAndLayoutDuration : 0;
              s += d - f, a += f, d > u && (r = t.startTime < e + n ? "input-delay" : t.startTime >= e + n + o ? "presentation-delay" : "processing-duration", i = t, u = d);
            }
          }
          const d = t.longAnimationFrameEntries.at(-1),
            f = d ? d.startTime + d.duration : 0;
          f >= e + n + o && (c = t.nextPaintTime - f), i && r && (t.longestScript = {
            entry: i,
            subpart: r,
            intersectingDuration: u
          }), t.totalScriptDuration = s, t.totalStyleAndLayoutDuration = a, t.totalPaintDuration = c, t.totalUnattributedDuration = t.nextPaintTime - e - s - a - c;
        })(h);
        return Object.assign(t, {
          attribution: h
        });
      };
    m("long-animation-frame", t => {
      r = r.concat(t), p();
    }), ((t, e = {}) => {
      globalThis.PerformanceEventTiming && "interactionId" in PerformanceEventTiming.prototype && D(() => {
        I();
        let n,
          o = h("INP");
        const i = s(e, W),
          r = t => {
            q(() => {
              for (const e of t) i.u(e);
              const e = i.M();
              e && e.T !== o.value && (o.value = e.T, o.entries = e.entries, n());
            });
          },
          a = m("event", r, {
            durationThreshold: e.durationThreshold ?? 40
          });
        n = d(t, o, x, e.reportAllChanges), a && (a.observe({
          type: "first-input",
          buffered: true
        }), document.addEventListener("visibilitychange", () => {
          "hidden" === document.visibilityState && (r(a.takeRecords()), n(true));
        }), u(() => {
          i.v(), o = h("INP"), n = d(t, o, x, e.reportAllChanges);
        }));
      });
    })(e => {
      const n = b(e);
      t(n);
    }, e);
  };
class R {
  m;
  u(t) {
    this.m?.(t);
  }
}
const U = [2500, 4e3],
  V = (t, n = {}) => {
    const o = s(n = Object.assign({}, n), R),
      r = new WeakMap();
    o.m = t => {
      if (t.element) {
        const e = (n.generateTarget ?? i)(t.element);
        r.set(t, e);
      }
    };
    ((t, e = {}) => {
      D(() => {
        const n = T();
        let o,
          i = h("LCP");
        const r = s(e, R),
          a = t => {
            e.reportAllChanges || (t = t.slice(-1));
            for (const e of t) r.u(e), e.startTime < n.firstHiddenTime && (i.value = Math.max(e.startTime - l(), 0), i.entries = [e], o());
          },
          c = m("largest-contentful-paint", a);
        if (c) {
          o = d(t, i, U, e.reportAllChanges);
          const n = g(() => {
            a(c.takeRecords()), c.disconnect(), o(true);
          });
          for (const t of ["keydown", "click", "visibilitychange"]) addEventListener(t, () => q(n), {
            capture: true,
            once: true
          });
          u(n => {
            i = h("LCP"), o = d(t, i, U, e.reportAllChanges), f(() => {
              i.value = performance.now() - n.timeStamp, o(true);
            });
          });
        }
      });
    })(n => {
      const o = (t => {
        let n = {
          timeToFirstByte: 0,
          resourceLoadDelay: 0,
          resourceLoadDuration: 0,
          elementRenderDelay: t.value
        };
        if (t.entries.length) {
          const o = e();
          if (o) {
            const e = o.activationStart || 0,
              i = t.entries.at(-1),
              s = i.url && performance.getEntriesByType("resource").filter(t => t.name === i.url)[0],
              a = Math.max(0, o.responseStart - e),
              c = Math.max(a, s ? (s.requestStart || s.startTime) - e : 0),
              u = Math.min(t.value, Math.max(c, s ? s.responseEnd - e : 0));
            n = {
              target: r.get(i),
              timeToFirstByte: a,
              resourceLoadDelay: c - a,
              resourceLoadDuration: u - c,
              elementRenderDelay: t.value - u,
              navigationEntry: o,
              lcpEntry: i
            }, i.url && (n.url = i.url), s && (n.lcpResourceEntry = s);
          }
        }
        return Object.assign(t, {
          attribution: n
        });
      })(n);
      t(o);
    }, n);
  },
  $ = [800, 1800],
  H = t => {
    document.prerendering ? D(() => H(t)) : "complete" !== document.readyState ? addEventListener("load", () => H(t), true) : setTimeout(t);
  },
  z = (t, n = {}) => {
    ((t, n = {}) => {
      let o = h("TTFB"),
        i = d(t, o, $, n.reportAllChanges);
      H(() => {
        const r = e();
        r && (o.value = Math.max(r.responseStart - l(), 0), o.entries = [r], i(true), u(() => {
          o = h("TTFB", 0), i = d(t, o, $, n.reportAllChanges), i(true);
        }));
      });
    })(e => {
      const n = (t => {
        let e = {
          waitingDuration: 0,
          cacheDuration: 0,
          dnsDuration: 0,
          connectionDuration: 0,
          requestDuration: 0
        };
        if (t.entries.length) {
          const n = t.entries[0],
            o = n.activationStart || 0,
            i = Math.max((n.workerStart || n.fetchStart) - o, 0),
            r = Math.max(n.domainLookupStart - o, 0),
            s = Math.max(n.connectStart - o, 0),
            a = Math.max(n.connectEnd - o, 0);
          e = {
            waitingDuration: i,
            cacheDuration: r - i,
            dnsDuration: s - r,
            connectionDuration: a - s,
            requestDuration: t.value - a,
            navigationEntry: n
          };
        }
        return Object.assign(t, {
          attribution: e
        });
      })(e);
      t(n);
    }, n);
  };

/**
 * Custom semantic attribute constants for the Honeycomb OpenTelemetry Web SDK.
 * These attributes extend the standard OpenTelemetry semantic conventions with
 * Honeycomb-specific and browser-specific attributes.
 *
 * https://github.com/open-telemetry/semantic-conventions/tree/main/model/browser
 */
// =============================================================================
// Browser Attributes
// =============================================================================
/**
 * The name of the browser.
 * @example "Chrome", "Firefox", "Safari"
 */
const ATTR_BROWSER_NAME = 'browser.name';
/**
 * The version of the browser.
 * @example "95.0.4638.54"
 */
const ATTR_BROWSER_VERSION = 'browser.version';
/**
 * Whether the browser has touch screen capabilities.
 * @example true, false
 */
const ATTR_BROWSER_TOUCH_SCREEN_ENABLED = 'browser.touch_screen_enabled';
/**
 * The current width of the browser viewport in pixels.
 * @example 1024
 */
const ATTR_BROWSER_WIDTH = 'browser.width';
/**
 * The current height of the browser viewport in pixels.
 * @example 768
 */
const ATTR_BROWSER_HEIGHT = 'browser.height';
// =============================================================================
// Device Attributes
// =============================================================================
/**
 * The type of device.
 * @example "desktop", "mobile", "tablet"
 */
const ATTR_DEVICE_TYPE = 'device.type';
// =============================================================================
// Network Attributes
// =============================================================================
/**
 * The effective network connection type.
 * @example "4g", "3g", "2g", "slow-2g", "unknown"
 */
const ATTR_NETWORK_EFFECTIVE_TYPE = 'network.effectiveType';
// =============================================================================
// Screen Attributes
// =============================================================================
/**
 * The width of the screen in pixels.
 * @example 1920
 */
const ATTR_SCREEN_WIDTH = 'screen.width';
/**
 * The height of the screen in pixels.
 * @example 1080
 */
const ATTR_SCREEN_HEIGHT = 'screen.height';
/**
 * The computed screen size category based on width.
 * @example "small", "medium", "large", "unknown"
 */
const ATTR_SCREEN_SIZE = 'screen.size';
// =============================================================================
// Page Attributes
// =============================================================================
/**
 * The current page URL hash fragment.
 * @example "#section1"
 */
const ATTR_PAGE_HASH = 'page.hash';
/**
 * The current page full URL.
 * @example "https://example.com/path?query=value#hash"
 */
const ATTR_PAGE_URL = 'page.url';
/**
 * The current page route/pathname.
 * @example "/products/123"
 */
const ATTR_PAGE_ROUTE = 'page.route';
/**
 * The current page hostname.
 * @example "example.com"
 */
const ATTR_PAGE_HOSTNAME = 'page.hostname';
/**
 * The current page search parameters.
 * @example "?query=value&sort=asc"
 */
const ATTR_PAGE_SEARCH = 'page.search';
// =============================================================================
// URL Attributes
// =============================================================================
/**
 * The current URL path.
 * @example "/products/123"
 */
const ATTR_URL_PATH = 'url.path';
// =============================================================================
// Entry Page Attributes
// =============================================================================
/**
 * The URL of the entry page (page where the session started).
 * @example "https://example.com/landing?utm_source=google"
 */
const ATTR_ENTRY_PAGE_URL = 'entry_page.url';
/**
 * The path of the entry page (page where the session started).
 * @example "/landing"
 */
const ATTR_ENTRY_PAGE_PATH = 'entry_page.path';
/**
 * The search parameters of the entry page.
 * @example "?utm_source=google&utm_medium=cpc"
 */
const ATTR_ENTRY_PAGE_SEARCH = 'entry_page.search';
/**
 * The hash fragment of the entry page.
 * @example "#welcome"
 */
const ATTR_ENTRY_PAGE_HASH = 'entry_page.hash';
/**
 * The hostname of the entry page.
 * @example "example.com"
 */
const ATTR_ENTRY_PAGE_HOSTNAME = 'entry_page.hostname';
/**
 * The referrer URL that led to the entry page.
 * @example "https://google.com/search?q=example"
 */
const ATTR_ENTRY_PAGE_REFERRER = 'entry_page.referrer';
// =============================================================================
// Honeycomb Distro Attributes
// =============================================================================
/**
 * The version of the Honeycomb distribution.
 * @example "1.2.3"
 */
const ATTR_HONEYCOMB_DISTRO_VERSION = 'honeycomb.distro.version';
/**
 * The runtime version of the Honeycomb distribution.
 * @example "browser"
 */
const ATTR_HONEYCOMB_DISTRO_RUNTIME_VERSION = 'honeycomb.distro.runtime_version';
// =============================================================================
// Web Vitals Attributes
// =============================================================================
// CLS (Cumulative Layout Shift) attributes
/**
 * CLS metric ID.
 * @example "v1-123456789"
 */
const ATTR_CLS_ID = 'cls.id';
/**
 * CLS metric value.
 * @example 0.123
 */
const ATTR_CLS_VALUE = 'cls.value';
/**
 * CLS metric delta.
 * @example 0.045
 */
const ATTR_CLS_DELTA = 'cls.delta';
/**
 * CLS metric rating.
 * @example "good", "needs-improvement", "poor"
 */
const ATTR_CLS_RATING = 'cls.rating';
/**
 * CLS navigation type.
 * @example "navigate", "reload", "back-forward"
 */
const ATTR_CLS_NAVIGATION_TYPE = 'cls.navigation_type';
// LCP (Largest Contentful Paint) attributes
/**
 * LCP metric ID.
 * @example "v1-123456789"
 */
const ATTR_LCP_ID = 'lcp.id';
/**
 * LCP metric value.
 * @example 1234.56
 */
const ATTR_LCP_VALUE = 'lcp.value';
/**
 * LCP metric delta.
 * @example 123.45
 */
const ATTR_LCP_DELTA = 'lcp.delta';
/**
 * LCP metric rating.
 * @example "good", "needs-improvement", "poor"
 */
const ATTR_LCP_RATING = 'lcp.rating';
/**
 * LCP navigation type.
 * @example "navigate", "reload", "back-forward"
 */
const ATTR_LCP_NAVIGATION_TYPE = 'lcp.navigation_type';
// INP (Interaction to Next Paint) attributes
/**
 * INP metric ID.
 * @example "v1-123456789"
 */
const ATTR_INP_ID = 'inp.id';
/**
 * INP metric value.
 * @example 89.12
 */
const ATTR_INP_VALUE = 'inp.value';
/**
 * INP metric delta.
 * @example 23.45
 */
const ATTR_INP_DELTA = 'inp.delta';
/**
 * INP metric rating.
 * @example "good", "needs-improvement", "poor"
 */
const ATTR_INP_RATING = 'inp.rating';
/**
 * INP navigation type.
 * @example "navigate", "reload", "back-forward"
 */
const ATTR_INP_NAVIGATION_TYPE = 'inp.navigation_type';
// FCP (First Contentful Paint) attributes
/**
 * FCP metric ID.
 * @example "v1-123456789"
 */
const ATTR_FCP_ID = 'fcp.id';
/**
 * FCP metric value.
 * @example 678.90
 */
const ATTR_FCP_VALUE = 'fcp.value';
/**
 * FCP metric delta.
 * @example 67.89
 */
const ATTR_FCP_DELTA = 'fcp.delta';
/**
 * FCP metric rating.
 * @example "good", "needs-improvement", "poor"
 */
const ATTR_FCP_RATING = 'fcp.rating';
/**
 * FCP navigation type.
 * @example "navigate", "reload", "back-forward"
 */
const ATTR_FCP_NAVIGATION_TYPE = 'fcp.navigation_type';
// TTFB (Time to First Byte) attributes
/**
 * TTFB metric ID.
 * @example "v1-123456789"
 */
const ATTR_TTFB_ID = 'ttfb.id';
/**
 * TTFB metric value.
 * @example 234.56
 */
const ATTR_TTFB_VALUE = 'ttfb.value';
/**
 * TTFB metric delta.
 * @example 34.56
 */
const ATTR_TTFB_DELTA = 'ttfb.delta';
/**
 * TTFB metric rating.
 * @example "good", "needs-improvement", "poor"
 */
const ATTR_TTFB_RATING = 'ttfb.rating';
/**
 * TTFB navigation type.
 * @example "navigate", "reload", "back-forward"
 */
const ATTR_TTFB_NAVIGATION_TYPE = 'ttfb.navigation_type';
// CLS (Cumulative Layout Shift) specific attributes
/**
 * The largest shift target element for CLS.
 * @example "div.main-content"
 */
const ATTR_CLS_LARGEST_SHIFT_TARGET = 'cls.largest_shift_target';
/**
 * The element that caused the largest shift for CLS.
 * @example "div.main-content"
 */
const ATTR_CLS_ELEMENT = 'cls.element';
/**
 * The time when the largest shift occurred for CLS.
 * @example 1234.56
 */
const ATTR_CLS_LARGEST_SHIFT_TIME = 'cls.largest_shift_time';
/**
 * The value of the largest shift for CLS.
 * @example 0.123
 */
const ATTR_CLS_LARGEST_SHIFT_VALUE = 'cls.largest_shift_value';
/**
 * The load state when CLS occurred.
 * @example "complete", "loading"
 */
const ATTR_CLS_LOAD_STATE = 'cls.load_state';
/**
 * Whether there was recent input before the CLS.
 * @example true, false
 */
const ATTR_CLS_HAD_RECENT_INPUT = 'cls.had_recent_input';
// LCP (Largest Contentful Paint) specific attributes
/**
 * The element that was the largest contentful paint.
 * @example "img.hero-image"
 */
const ATTR_LCP_ELEMENT = 'lcp.element';
/**
 * The URL of the resource for LCP.
 * @example "https://example.com/hero.jpg"
 */
const ATTR_LCP_URL = 'lcp.url';
/**
 * Time to first byte for LCP.
 * @example 123.45
 */
const ATTR_LCP_TIME_TO_FIRST_BYTE = 'lcp.time_to_first_byte';
/**
 * Resource load delay for LCP.
 * @example 45.67
 */
const ATTR_LCP_RESOURCE_LOAD_DELAY = 'lcp.resource_load_delay';
/**
 * Resource load duration for LCP.
 * @example 89.12
 */
const ATTR_LCP_RESOURCE_LOAD_DURATION = 'lcp.resource_load_duration';
/**
 * Element render delay for LCP.
 * @example 12.34
 */
const ATTR_LCP_ELEMENT_RENDER_DELAY = 'lcp.element_render_delay';
/**
 * Resource load time for LCP (deprecated, use resource_load_duration).
 * @example 89.12
 * @deprecated Use ATTR_LCP_RESOURCE_LOAD_DURATION instead
 */
const ATTR_LCP_RESOURCE_LOAD_TIME = 'lcp.resource_load_time';
// INP (Interaction to Next Paint) specific attributes
/**
 * Input delay for INP.
 * @example 12.34
 */
const ATTR_INP_INPUT_DELAY = 'inp.input_delay';
/**
 * Interaction target for INP.
 * @example "button.submit"
 */
const ATTR_INP_INTERACTION_TARGET = 'inp.interaction_target';
/**
 * Interaction time for INP.
 * @example 1234567890123
 */
const ATTR_INP_INTERACTION_TIME = 'inp.interaction_time';
/**
 * Interaction type for INP.
 * @example "click", "keydown"
 */
const ATTR_INP_INTERACTION_TYPE = 'inp.interaction_type';
/**
 * Load state when INP occurred.
 * @example "complete", "loading"
 */
const ATTR_INP_LOAD_STATE = 'inp.load_state';
/**
 * Next paint time for INP.
 * @example 1234567890234
 */
const ATTR_INP_NEXT_PAINT_TIME = 'inp.next_paint_time';
/**
 * Presentation delay for INP.
 * @example 23.45
 */
const ATTR_INP_PRESENTATION_DELAY = 'inp.presentation_delay';
/**
 * Processing duration for INP.
 * @example 34.56
 */
const ATTR_INP_PROCESSING_DURATION = 'inp.processing_duration';
/**
 * Total duration for INP.
 * @example 70.35
 */
const ATTR_INP_DURATION = 'inp.duration';
/**
 * Element for INP (deprecated, use interaction_target).
 * @example "button.submit"
 * @deprecated Use ATTR_INP_INTERACTION_TARGET instead
 */
const ATTR_INP_ELEMENT = 'inp.element';
/**
 * Event type for INP (deprecated, use interaction_type).
 * @example "click"
 * @deprecated Use ATTR_INP_INTERACTION_TYPE instead
 */
const ATTR_INP_EVENT_TYPE = 'inp.event_type';
// INP Script Timing attributes
/**
 * Script entry type for INP timing.
 * @example "script"
 */
const ATTR_INP_SCRIPT_ENTRY_TYPE = 'inp.timing.script.entry_type';
/**
 * Script start time for INP timing.
 * @example 1234567890123
 */
const ATTR_INP_SCRIPT_START_TIME = 'inp.timing.script.start_time';
/**
 * Script execution start for INP timing.
 * @example 1234567890125
 */
const ATTR_INP_SCRIPT_EXECUTION_START = 'inp.timing.script.execution_start';
/**
 * Script duration for INP timing.
 * @example 45.67
 */
const ATTR_INP_SCRIPT_DURATION = 'inp.timing.script.duration';
/**
 * Script forced style and layout duration for INP timing.
 * @example 12.34
 */
const ATTR_INP_SCRIPT_FORCED_STYLE_AND_LAYOUT_DURATION = 'inp.timing.script.forced_style_and_layout_duration';
/**
 * Script invoker for INP timing.
 * @example "event-listener"
 */
const ATTR_INP_SCRIPT_INVOKER = 'inp.timing.script.invoker';
/**
 * Script pause duration for INP timing.
 * @example 5.67
 */
const ATTR_INP_SCRIPT_PAUSE_DURATION = 'inp.timing.script.pause_duration';
/**
 * Script source URL for INP timing.
 * @example "https://example.com/script.js"
 */
const ATTR_INP_SCRIPT_SOURCE_URL = 'inp.timing.script.source_url';
/**
 * Script source function name for INP timing.
 * @example "handleClick"
 */
const ATTR_INP_SCRIPT_SOURCE_FUNCTION_NAME = 'inp.timing.script.source_function_name';
/**
 * Script source character position for INP timing.
 * @example 123
 */
const ATTR_INP_SCRIPT_SOURCE_CHAR_POSITION = 'inp.timing.script.source_char_position';
/**
 * Script window attribution for INP timing.
 * @example "self"
 */
const ATTR_INP_SCRIPT_WINDOW_ATTRIBUTION = 'inp.timing.script.window_attribution';
// INP Long Animation Frame Timing attributes
/**
 * Long animation frame duration for INP timing.
 * @example 123.45
 */
const ATTR_INP_TIMING_DURATION = 'inp.timing.duration';
/**
 * Long animation frame entry type for INP timing.
 * @example "long-animation-frame"
 */
const ATTR_INP_TIMING_ENTRY_TYPE = 'inp.timing.entryType';
/**
 * Long animation frame name for INP timing.
 * @example "same-origin-descendant"
 */
const ATTR_INP_TIMING_NAME = 'inp.timing.name';
/**
 * Long animation frame render start for INP timing.
 * @example 1234567890234
 */
const ATTR_INP_TIMING_RENDER_START = 'inp.timing.renderStart';
/**
 * Long animation frame start time for INP timing.
 * @example 1234567890123
 */
const ATTR_INP_TIMING_START_TIME = 'inp.timing.startTime';
// FCP (First Contentful Paint) specific attributes
/**
 * Time to first byte for FCP.
 * @example 123.45
 */
const ATTR_FCP_TIME_TO_FIRST_BYTE = 'fcp.time_to_first_byte';
/**
 * Time since first byte for FCP.
 * @example 67.89
 */
const ATTR_FCP_TIME_SINCE_FIRST_BYTE = 'fcp.time_since_first_byte';
/**
 * Load state when FCP occurred.
 * @example "complete", "loading"
 */
const ATTR_FCP_LOAD_STATE = 'fcp.load_state';
// TTFB (Time to First Byte) specific attributes
/**
 * Waiting duration for TTFB.
 * @example 45.67
 */
const ATTR_TTFB_WAITING_DURATION = 'ttfb.waiting_duration';
/**
 * DNS duration for TTFB.
 * @example 12.34
 */
const ATTR_TTFB_DNS_DURATION = 'ttfb.dns_duration';
/**
 * Connection duration for TTFB.
 * @example 23.45
 */
const ATTR_TTFB_CONNECTION_DURATION = 'ttfb.connection_duration';
/**
 * Request duration for TTFB.
 * @example 34.56
 */
const ATTR_TTFB_REQUEST_DURATION = 'ttfb.request_duration';
/**
 * Cache duration for TTFB.
 * @example 5.67
 */
const ATTR_TTFB_CACHE_DURATION = 'ttfb.cache_duration';
/**
 * Waiting time for TTFB (deprecated, use waiting_duration).
 * @example 45.67
 * @deprecated Use ATTR_TTFB_WAITING_DURATION instead
 */
const ATTR_TTFB_WAITING_TIME = 'ttfb.waiting_time';
/**
 * DNS time for TTFB (deprecated, use dns_duration).
 * @example 12.34
 * @deprecated Use ATTR_TTFB_DNS_DURATION instead
 */
const ATTR_TTFB_DNS_TIME = 'ttfb.dns_time';
/**
 * Connection time for TTFB (deprecated, use connection_duration).
 * @example 23.45
 * @deprecated Use ATTR_TTFB_CONNECTION_DURATION instead
 */
const ATTR_TTFB_CONNECTION_TIME = 'ttfb.connection_time';
/**
 * Request time for TTFB (deprecated, use request_duration).
 * @example 34.56
 * @deprecated Use ATTR_TTFB_REQUEST_DURATION instead
 */
const ATTR_TTFB_REQUEST_TIME = 'ttfb.request_time';

// To avoid importing InstrumentationAbstract from:
// import { InstrumentationAbstract } from '@opentelemetry/instrumentation/build/src/instrumentation';
// When this is exposed we can import from there.
class InstrumentationAbstract {
  constructor(instrumentationName, instrumentationVersion, config = {}) {
    this.instrumentationName = instrumentationName;
    this.instrumentationVersion = instrumentationVersion;
    /* Api to wrap instrumented method */
    // eslint-disable-next-line @typescript-eslint/unbound-method
    this._wrap = shimmer__namespace.wrap;
    /* Api to unwrap instrumented methods */
    // eslint-disable-next-line @typescript-eslint/unbound-method
    this._unwrap = shimmer__namespace.unwrap;
    /* Api to mass wrap instrumented method */
    // eslint-disable-next-line @typescript-eslint/unbound-method
    this._massWrap = shimmer__namespace.massWrap;
    /* Api to mass unwrap instrumented methods */
    // eslint-disable-next-line @typescript-eslint/unbound-method
    this._massUnwrap = shimmer__namespace.massUnwrap;
    this._config = Object.assign({
      enabled: true
    }, config);
    this._diag = api.diag.createComponentLogger({
      namespace: instrumentationName
    });
    this._tracer = api.trace.getTracer(instrumentationName, instrumentationVersion);
    this._meter = api.metrics.getMeter(instrumentationName, instrumentationVersion);
    this._updateMetricInstruments();
  }
  /* Returns meter */
  get meter() {
    return this._meter;
  }
  /**
   * Sets MeterProvider to this plugin
   * @param meterProvider
   */
  setMeterProvider(meterProvider) {
    this._meter = meterProvider.getMeter(this.instrumentationName, this.instrumentationVersion);
    this._updateMetricInstruments();
  }
  /**
   * Sets the new metric instruments with the current Meter.
   */
  _updateMetricInstruments() {
    return;
  }
  /* Returns InstrumentationConfig */
  getConfig() {
    return this._config;
  }
  /**
   * Sets InstrumentationConfig to this plugin
   * @param InstrumentationConfig
   */
  setConfig(config = {}) {
    this._config = Object.assign({}, config);
  }
  /**
   * Sets TraceProvider to this plugin
   * @param tracerProvider
   */
  setTracerProvider(tracerProvider) {
    this._tracer = tracerProvider.getTracer(this.instrumentationName, this.instrumentationVersion);
  }
  /* Returns tracer */
  get tracer() {
    return this._tracer;
  }
}
/**
 * Web vitals auto-instrumentation, sends spans automatically for CLS, LCP, INP, FCP, TTFB.
 * Defaults to sending spans for CLS, LCP, INP, FCP and TTFB.
 * @param config The {@link WebVitalsInstrumentationConfig }
 */
class WebVitalsInstrumentation extends InstrumentationAbstract {
  constructor({
    enabled = true,
    vitalsToTrack = ['CLS', 'LCP', 'INP', 'TTFB', 'FCP'],
    lcp,
    cls,
    inp,
    fcp,
    ttfb
  } = {}) {
    const config = {
      enabled,
      vitalsToTrack,
      lcp,
      cls,
      inp,
      fcp,
      ttfb
    };
    super('@honeycombio/instrumentation-web-vitals', userInteractionInstrumentation.VERSION, config);
    this.onReportCLS = (cls, clsOpts = {}) => {
      const {
        applyCustomAttributes
      } = clsOpts;
      if (!this.isEnabled()) return;
      const {
        name,
        attribution
      } = cls;
      const {
        largestShiftTarget,
        largestShiftTime,
        largestShiftValue,
        loadState,
        largestShiftEntry
      } = attribution;
      const span = this.tracer.startSpan(name);
      span.setAttributes({
        [ATTR_CLS_ID]: cls.id,
        [ATTR_CLS_DELTA]: cls.delta,
        [ATTR_CLS_VALUE]: cls.value,
        [ATTR_CLS_RATING]: cls.rating,
        [ATTR_CLS_NAVIGATION_TYPE]: cls.navigationType,
        [ATTR_CLS_LARGEST_SHIFT_TARGET]: largestShiftTarget,
        [ATTR_CLS_ELEMENT]: largestShiftTarget,
        [ATTR_CLS_LARGEST_SHIFT_TIME]: largestShiftTime,
        [ATTR_CLS_LARGEST_SHIFT_VALUE]: largestShiftValue,
        [ATTR_CLS_LOAD_STATE]: loadState,
        [ATTR_CLS_HAD_RECENT_INPUT]: largestShiftEntry === null || largestShiftEntry === void 0 ? void 0 : largestShiftEntry.hadRecentInput
      });
      if (applyCustomAttributes) {
        applyCustomAttributes(cls, span);
      }
      span.end();
    };
    this.onReportLCP = (lcp, lcpOpts = {}) => {
      const {
        applyCustomAttributes,
        dataAttributes
      } = lcpOpts;
      if (!this.isEnabled()) return;
      const {
        name,
        attribution
      } = lcp;
      const {
        target,
        url,
        timeToFirstByte,
        resourceLoadDelay,
        resourceLoadDuration,
        elementRenderDelay,
        lcpEntry
      } = attribution;
      const span = this.tracer.startSpan(name);
      span.setAttributes({
        [ATTR_LCP_ID]: lcp.id,
        [ATTR_LCP_DELTA]: lcp.delta,
        [ATTR_LCP_VALUE]: lcp.value,
        [ATTR_LCP_RATING]: lcp.rating,
        [ATTR_LCP_NAVIGATION_TYPE]: lcp.navigationType,
        [ATTR_LCP_ELEMENT]: target,
        [ATTR_LCP_URL]: url,
        [ATTR_LCP_TIME_TO_FIRST_BYTE]: timeToFirstByte,
        [ATTR_LCP_RESOURCE_LOAD_DELAY]: resourceLoadDelay,
        [ATTR_LCP_RESOURCE_LOAD_DURATION]: resourceLoadDuration,
        [ATTR_LCP_ELEMENT_RENDER_DELAY]: elementRenderDelay,
        // This will be deprecated in a future version
        [ATTR_LCP_RESOURCE_LOAD_TIME]: resourceLoadDuration
      });
      this.addDataAttributes(lcpEntry === null || lcpEntry === void 0 ? void 0 : lcpEntry.element, span, dataAttributes, 'lcp');
      if (applyCustomAttributes) {
        applyCustomAttributes(lcp, span);
      }
      span.end();
    };
    this.onReportINP = (inp, inpOpts = {
      includeTimingsAsSpans: false
    }) => {
      const {
        applyCustomAttributes,
        includeTimingsAsSpans,
        dataAttributes
      } = inpOpts;
      if (!this.isEnabled()) return;
      const {
        name,
        attribution
      } = inp;
      const {
        inputDelay,
        interactionTarget,
        interactionTime,
        interactionType,
        loadState,
        nextPaintTime,
        presentationDelay,
        processingDuration,
        longAnimationFrameEntries
      } = attribution;
      const inpDuration = inputDelay + processingDuration + presentationDelay;
      this.tracer.startActiveSpan(name, {
        startTime: interactionTime
      }, inpSpan => {
        const inpAttributes = {
          [ATTR_INP_ID]: inp.id,
          [ATTR_INP_DELTA]: inp.delta,
          [ATTR_INP_VALUE]: inp.value,
          [ATTR_INP_RATING]: inp.rating,
          [ATTR_INP_NAVIGATION_TYPE]: inp.navigationType,
          [ATTR_INP_INPUT_DELAY]: inputDelay,
          [ATTR_INP_INTERACTION_TARGET]: interactionTarget,
          [ATTR_INP_INTERACTION_TIME]: interactionTime,
          [ATTR_INP_INTERACTION_TYPE]: interactionType,
          [ATTR_INP_LOAD_STATE]: loadState,
          [ATTR_INP_NEXT_PAINT_TIME]: nextPaintTime,
          [ATTR_INP_PRESENTATION_DELAY]: presentationDelay,
          [ATTR_INP_PROCESSING_DURATION]: processingDuration,
          [ATTR_INP_DURATION]: inpDuration,
          // These will be deprecated in a future version
          [ATTR_INP_ELEMENT]: interactionTarget,
          [ATTR_INP_EVENT_TYPE]: interactionType
        };
        inpSpan.setAttributes(inpAttributes);
        inp.entries.forEach(inpEntry => {
          this.addDataAttributes(this.getElementFromNode(inpEntry.target), inpSpan, dataAttributes, 'inp');
        });
        if (applyCustomAttributes) {
          applyCustomAttributes(inp, inpSpan);
        }
        if (includeTimingsAsSpans) {
          longAnimationFrameEntries.forEach(perfEntry => {
            this.processPerformanceLongAnimationFrameTimingSpans('inp', perfEntry);
          });
        }
        inpSpan.end(interactionTime + inpDuration);
      });
    };
    this.onReportFCP = (fcp, fcpOpts = {}) => {
      const {
        applyCustomAttributes
      } = fcpOpts;
      if (!this.isEnabled()) return;
      const {
        name,
        attribution
      } = fcp;
      const {
        timeToFirstByte,
        firstByteToFCP,
        loadState
      } = attribution;
      const span = this.tracer.startSpan(name);
      span.setAttributes({
        [ATTR_FCP_ID]: fcp.id,
        [ATTR_FCP_DELTA]: fcp.delta,
        [ATTR_FCP_VALUE]: fcp.value,
        [ATTR_FCP_RATING]: fcp.rating,
        [ATTR_FCP_NAVIGATION_TYPE]: fcp.navigationType,
        [ATTR_FCP_TIME_TO_FIRST_BYTE]: timeToFirstByte,
        [ATTR_FCP_TIME_SINCE_FIRST_BYTE]: firstByteToFCP,
        [ATTR_FCP_LOAD_STATE]: loadState
      });
      if (applyCustomAttributes) {
        applyCustomAttributes(fcp, span);
      }
      span.end();
    };
    this.onReportTTFB = (ttfb, ttfbOpts = {}) => {
      const {
        applyCustomAttributes
      } = ttfbOpts;
      if (!this.isEnabled()) return;
      const {
        name,
        attribution
      } = ttfb;
      const {
        cacheDuration,
        connectionDuration,
        dnsDuration,
        requestDuration,
        waitingDuration
      } = attribution;
      const attributes = {
        [ATTR_TTFB_ID]: ttfb.id,
        [ATTR_TTFB_DELTA]: ttfb.delta,
        [ATTR_TTFB_VALUE]: ttfb.value,
        [ATTR_TTFB_RATING]: ttfb.rating,
        [ATTR_TTFB_NAVIGATION_TYPE]: ttfb.navigationType,
        [ATTR_TTFB_WAITING_DURATION]: waitingDuration,
        [ATTR_TTFB_DNS_DURATION]: dnsDuration,
        [ATTR_TTFB_CONNECTION_DURATION]: connectionDuration,
        [ATTR_TTFB_REQUEST_DURATION]: requestDuration,
        [ATTR_TTFB_CACHE_DURATION]: cacheDuration,
        // These will be deprecated ina future version
        [ATTR_TTFB_WAITING_TIME]: waitingDuration,
        [ATTR_TTFB_DNS_TIME]: dnsDuration,
        [ATTR_TTFB_CONNECTION_TIME]: connectionDuration,
        [ATTR_TTFB_REQUEST_TIME]: requestDuration
      };
      const span = this.tracer.startSpan(name);
      span.setAttributes(attributes);
      if (applyCustomAttributes) {
        applyCustomAttributes(ttfb, span);
      }
      span.end();
    };
    this.vitalsToTrack = [...vitalsToTrack];
    this.lcpOpts = lcp;
    this.clsOpts = cls;
    this.inpOpts = inp;
    this.fcpOpts = fcp;
    this.ttfbOpts = ttfb;
    this._isEnabled = enabled;
    this._setupWebVitalsCallbacks();
  }
  init() {}
  _setupWebVitalsCallbacks() {
    if (this.vitalsToTrack.includes('CLS')) {
      _(vital => {
        this.onReportCLS(vital, this.clsOpts);
      }, this.clsOpts);
    }
    if (this.vitalsToTrack.includes('LCP')) {
      V(vital => {
        this.onReportLCP(vital, this.lcpOpts);
      }, this.lcpOpts);
    }
    if (this.vitalsToTrack.includes('INP')) {
      N(vital => {
        this.onReportINP(vital, this.inpOpts);
      }, this.inpOpts);
    }
    if (this.vitalsToTrack.includes('TTFB')) {
      z(vital => {
        this.onReportTTFB(vital, this.ttfbOpts);
      }, this.ttfbOpts);
    }
    if (this.vitalsToTrack.includes('FCP')) {
      w(vital => {
        this.onReportFCP(vital, this.fcpOpts);
      }, this.fcpOpts);
    }
  }
  getAttrPrefix(name) {
    return name.toLowerCase();
  }
  getAttributesForPerformanceLongAnimationFrameTiming(perfEntry) {
    const loafAttributes = {
      [ATTR_INP_TIMING_DURATION]: perfEntry.duration,
      [ATTR_INP_TIMING_ENTRY_TYPE]: perfEntry.entryType,
      [ATTR_INP_TIMING_NAME]: perfEntry.name,
      [ATTR_INP_TIMING_RENDER_START]: perfEntry.renderStart,
      [ATTR_INP_TIMING_START_TIME]: perfEntry.startTime
    };
    return loafAttributes;
  }
  getAttributesForPerformanceScriptTiming(scriptPerfEntry) {
    const scriptAttributes = {
      [ATTR_INP_SCRIPT_ENTRY_TYPE]: scriptPerfEntry.entryType,
      [ATTR_INP_SCRIPT_START_TIME]: scriptPerfEntry.startTime,
      [ATTR_INP_SCRIPT_EXECUTION_START]: scriptPerfEntry.executionStart,
      [ATTR_INP_SCRIPT_DURATION]: scriptPerfEntry.duration,
      [ATTR_INP_SCRIPT_FORCED_STYLE_AND_LAYOUT_DURATION]: scriptPerfEntry.forcedStyleAndLayoutDuration,
      [ATTR_INP_SCRIPT_INVOKER]: scriptPerfEntry.invoker,
      [ATTR_INP_SCRIPT_PAUSE_DURATION]: scriptPerfEntry.pauseDuration,
      [ATTR_INP_SCRIPT_SOURCE_URL]: scriptPerfEntry.sourceURL,
      [ATTR_INP_SCRIPT_SOURCE_FUNCTION_NAME]: scriptPerfEntry.sourceFunctionName,
      [ATTR_INP_SCRIPT_SOURCE_CHAR_POSITION]: scriptPerfEntry.sourceCharPosition,
      [ATTR_INP_SCRIPT_WINDOW_ATTRIBUTION]: scriptPerfEntry.windowAttribution
    };
    return scriptAttributes;
  }
  processPerformanceLongAnimationFrameTimingSpans(parentPrefix, perfEntry) {
    if (!perfEntry) return;
    const loafAttributes = this.getAttributesForPerformanceLongAnimationFrameTiming(perfEntry);
    this.tracer.startActiveSpan(perfEntry.name, {
      startTime: perfEntry.startTime
    }, span => {
      span.setAttributes(loafAttributes);
      this.processPerformanceScriptTimingSpans(parentPrefix, perfEntry.scripts);
      span.end(perfEntry.startTime + perfEntry.duration);
    });
  }
  processPerformanceScriptTimingSpans(parentPrefix, perfScriptEntries) {
    if (!perfScriptEntries) return;
    if (!(perfScriptEntries === null || perfScriptEntries === void 0 ? void 0 : perfScriptEntries.length)) return;
    perfScriptEntries.map(scriptPerfEntry => {
      this.tracer.startActiveSpan(scriptPerfEntry.name, {
        startTime: scriptPerfEntry.startTime
      }, span => {
        const scriptAttributes = this.getAttributesForPerformanceScriptTiming(scriptPerfEntry);
        span.setAttributes(scriptAttributes);
        span.end(scriptPerfEntry.startTime + scriptPerfEntry.duration);
      });
    });
  }
  getElementFromNode(node) {
    if ((node === null || node === void 0 ? void 0 : node.nodeType) === Node.ELEMENT_NODE) {
      return node;
    }
    return undefined;
  }
  addDataAttributes(element, span, dataAttributes, attrPrefix) {
    const el = element;
    if (el === null || el === void 0 ? void 0 : el.dataset) {
      for (const attrName in el.dataset) {
        const attrValue = el.dataset[attrName];
        if (
        // Value exists (including the empty string AND either
        attrValue !== undefined && (
        // dataAttributes is undefined (i.e. send all values as span attributes) OR
        dataAttributes === undefined ||
        // dataAttributes is specified AND attrName is in dataAttributes (i.e attribute name is in the supplied allowList)
        dataAttributes.includes(attrName))) {
          span.setAttribute(`${attrPrefix}.element.data.${attrName}`, attrValue);
        }
      }
    }
  }
  disable() {
    if (!this.isEnabled()) {
      this._diag.debug(`Instrumentation already disabled`);
      return;
    }
    this._isEnabled = false;
    this._diag.debug(`Instrumentation  disabled`);
  }
  enable() {
    if (this.isEnabled()) {
      this._diag.debug(`Instrumentation already enabled`);
      return;
    }
    this._isEnabled = true;
    this._diag.debug(`Instrumentation  enabled`);
    this._diag.debug(`Sending spans for ${this.vitalsToTrack.join(',')}`);
  }
  isEnabled() {
    return this._isEnabled;
  }
}

const LIBRARY_NAME = '@honeycombio/instrumentation-global-errors';
/**
 * Extracts and structures the stack trace from an error object.
 *
 * This function breaks down the stack trace into arrays of strings and numbers
 * to comply with OTLP (OpenTelemetry Protocol) requirements, which do not accept
 * arrays of objects.
 *
 * @param {Error | undefined} error - The error object from which to extract the stack trace.
 * @returns {Object} An object containing structured stack trace information with arrays of columns, lines, functions, and URLs.
 */
function getStructuredStackTrace(error) {
  if (!error) {
    return {};
  }
  // OTLP does not accept arrays of objects
  // breaking down the stack into arrays of strings/numbers
  const structuredStack = tracekit.computeStackTrace(error).stack;
  const lines = [];
  const columns = [];
  const functions = [];
  const urls = [];
  if (!Array.isArray(structuredStack)) {
    return {};
  }
  structuredStack.forEach(stackFrame => {
    lines.push(stackFrame.line);
    columns.push(stackFrame.column);
    functions.push(stackFrame.func);
    urls.push(stackFrame.url);
  });
  return {
    'exception.structured_stacktrace.columns': columns,
    'exception.structured_stacktrace.lines': lines,
    'exception.structured_stacktrace.functions': functions,
    'exception.structured_stacktrace.urls': urls
  };
}
/**
 * Records an exception as a span in the OpenTelemetry tracer.
 *
 * @param {Error} error - The error object to record.
 * @param {Attributes} [attributes={}] - Additional attributes to add to the span.
 * @param {Tracer} [tracer=trace.getTracer(LIBRARY_NAME)] - The tracer to use for recording the span.
 * @param {ApplyCustomErrorAttributesOnSpanFn} applyCustomAttributesOnSpan - Callback function to add custom attributes to the span and mutate the span.
 */
function recordException(error, attributes = {}, tracer = api.trace.getTracer(LIBRARY_NAME), applyCustomAttributesOnSpan) {
  const message = error.message;
  const type = error.name;
  const errorAttributes = Object.assign(Object.assign({
    [semanticConventions.ATTR_EXCEPTION_TYPE]: type,
    [semanticConventions.ATTR_EXCEPTION_MESSAGE]: message,
    [semanticConventions.ATTR_EXCEPTION_STACKTRACE]: error.stack
  }, getStructuredStackTrace(error)), attributes);
  const errorSpan = tracer.startSpan('exception', {
    attributes: errorAttributes
  }, api.context.active());
  if (applyCustomAttributesOnSpan) {
    applyCustomAttributesOnSpan(errorSpan, error);
  }
  errorSpan.setStatus({
    code: api.SpanStatusCode.ERROR,
    message
  });
  errorSpan.end();
}
/**
 * Global errors auto-instrumentation, sends spans automatically for exceptions that reach the window.
 * @param config The {@link GlobalErrorsInstrumentationConfig}
 */
class GlobalErrorsInstrumentation extends InstrumentationAbstract {
  constructor({
    enabled = true,
    applyCustomAttributesOnSpan
  } = {}) {
    const config = {
      enabled,
      applyCustomAttributesOnSpan
    };
    super(LIBRARY_NAME, userInteractionInstrumentation.VERSION, config);
    this.onError = event => {
      const error = 'reason' in event ? event.reason : event.error;
      console.log(this.applyCustomAttributesOnSpan);
      if (error) {
        recordException(error, {}, this.tracer, this.applyCustomAttributesOnSpan);
      }
    };
    if (enabled) {
      this.enable();
    }
    this._isEnabled = enabled;
    this.applyCustomAttributesOnSpan = applyCustomAttributesOnSpan;
  }
  init() {}
  disable() {
    if (!this.isEnabled()) {
      this._diag.debug(`Instrumentation already disabled`);
      return;
    }
    this._isEnabled = false;
    window.removeEventListener('error', this.onError);
    window.removeEventListener('unhandledrejection', this.onError);
    this._diag.debug(`Instrumentation  disabled`);
  }
  enable() {
    if (this.isEnabled()) {
      this._diag.debug(`Instrumentation already enabled`);
      return;
    }
    this._isEnabled = true;
    window.addEventListener('error', this.onError);
    window.addEventListener('unhandledrejection', this.onError);
    this._diag.debug(`Instrumentation  enabled`);
  }
  isEnabled() {
    return this._isEnabled;
  }
}

const TEAM_HEADER_KEY = 'x-honeycomb-team';
const DATASET_HEADER_KEY = 'x-honeycomb-dataset';
/**
 * Builds and returns an OTLP Traces exporter that sends data over http/json
 * @param options The {@link HoneycombOptions} used to configure the exporter
 * @returns a {@link SpanExporter} configured to send telemetry to Honeycomb over http/json
 */
function configureHoneycombHttpJsonTraceExporter(options) {
  const apiKey = getTracesApiKey(options);
  return new exporterTraceOtlpHttp.OTLPTraceExporter({
    url: getTracesEndpoint(options),
    headers: configureHeaders(options, apiKey, options === null || options === void 0 ? void 0 : options.tracesHeaders),
    timeoutMillis: (options === null || options === void 0 ? void 0 : options.tracesTimeout) || (options === null || options === void 0 ? void 0 : options.timeout) || 10000
  });
}
/**
 * Builds and returns an OTLP Metrics exporter that sends data over http/json
 * @param options The {@link HoneycombOptions} used to configure the exporter
 * @returns an {@link OTLPMetricExporter} configured to send telemetry to Honeycomb over http/json
 */
function configureHoneycombHttpJsonMetricExporter(options) {
  const apiKey = getMetricsApiKey(options);
  return new exporterMetricsOtlpHttp.OTLPMetricExporter({
    url: getMetricsEndpoint(options),
    headers: configureHeaders(options, apiKey, options === null || options === void 0 ? void 0 : options.metricsHeaders, true),
    timeoutMillis: (options === null || options === void 0 ? void 0 : options.metricsTimeout) || (options === null || options === void 0 ? void 0 : options.timeout) || 10000
  });
}
/**
 * Builds and returns an OTLP Logs exporter that sends data over http/json
 * @param options The {@link HoneycombOptions} used to configure the exporter
 * @returns an {@link OTLPLogExporter} configured to send telemetry to Honeycomb over http/json
 */
function configureHoneycombHttpJsonLogExporter(options) {
  const apiKey = getLogsApiKey(options);
  return new exporterLogsOtlpHttp.OTLPLogExporter({
    url: getLogsEndpoint(options),
    headers: configureHeaders(options, apiKey, options === null || options === void 0 ? void 0 : options.logsHeaders),
    timeoutMillis: (options === null || options === void 0 ? void 0 : options.logsTimeout) || (options === null || options === void 0 ? void 0 : options.timeout) || 10000
  });
}
function configureHeaders(options, apiKey, signalHeaders, isMetrics = false) {
  const headers = Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.headers), signalHeaders);
  if (apiKey && !headers[TEAM_HEADER_KEY]) {
    headers[TEAM_HEADER_KEY] = apiKey;
  }
  if (isClassic(apiKey)) {
    if (isMetrics && (options === null || options === void 0 ? void 0 : options.metricsDataset)) {
      headers[DATASET_HEADER_KEY] = options === null || options === void 0 ? void 0 : options.metricsDataset;
    } else if (options === null || options === void 0 ? void 0 : options.dataset) {
      headers[DATASET_HEADER_KEY] = options === null || options === void 0 ? void 0 : options.dataset;
    }
  }
  return headers;
}

/**
 * Builds and returns a {@link SpanExporter} that logs Honeycomb URLs for completed traces
 *
 * @remark This is not for production use.
 * @param options The {@link HoneycombOptions} used to configure the exporter
 * @returns the configured {@link ConsoleTraceLinkExporter} instance
 */
function configureConsoleTraceLinkExporter(options) {
  const apiKey = getTracesApiKey(options);
  const {
    authRoot,
    uiRoot
  } = getUrlRoots((options === null || options === void 0 ? void 0 : options.tracesEndpoint) || getTracesEndpoint(options));
  return new ConsoleTraceLinkExporter(options === null || options === void 0 ? void 0 : options.serviceName, apiKey, options === null || options === void 0 ? void 0 : options.logLevel, authRoot, uiRoot);
}
const getUrlRoots = (endpoint = '') => {
  const url = new URL(endpoint);
  const subdomainRegex = /(api)([.|-])?(.*?)(\.?)(honeycomb\.io)(.*)/;
  const matches = subdomainRegex.exec(url.host);
  if (matches === null) {
    return {
      authRoot: undefined,
      uiRoot: undefined
    };
  }
  const isDashSubdomain = matches[2] === '-';
  let apiSubdomain;
  let uiSubdomain;
  if (isDashSubdomain) {
    apiSubdomain = `api-${matches[3]}`;
    uiSubdomain = `ui-${matches[3]}`;
  } else {
    apiSubdomain = matches[3] ? `api.${matches[3]}` : 'api';
    uiSubdomain = matches[3] ? `ui.${matches[3]}` : 'ui';
  }
  const authRoot = `${url.protocol}//${apiSubdomain}.honeycomb.io/1/auth`;
  const uiRoot = `${url.protocol}//${uiSubdomain}.honeycomb.io`;
  return {
    authRoot,
    uiRoot
  };
};
/**
 * A custom {@link SpanExporter} that logs Honeycomb URLs for completed traces.
 *
 * @remark This is not for production use.
 */
class ConsoleTraceLinkExporter {
  constructor(serviceName, apikey, logLevel, authRoot, uiRoot) {
    this._traceUrl = '';
    this._logLevel = api.DiagLogLevel.DEBUG;
    if (logLevel) {
      this._logLevel = logLevel;
    }
    if (!serviceName || !apikey) {
      if (this._logLevel >= api.DiagLogLevel.DEBUG) {
        console.debug(MISSING_FIELDS_FOR_LOCAL_VISUALIZATIONS);
      }
      return;
    }
    if (!authRoot || !uiRoot) {
      if (this._logLevel >= api.DiagLogLevel.DEBUG) {
        console.debug(MISSING_FIELDS_FOR_GENERATING_LINKS);
      }
      return;
    }
    const options = {
      headers: {
        'x-honeycomb-team': apikey
      }
    };
    fetch(authRoot, options).then(resp => {
      if (resp.ok) {
        return resp.json();
      }
      throw new Error();
    }).then(data => {
      var _a, _b, _c;
      const respData = data;
      if ((_a = respData.team) === null || _a === void 0 ? void 0 : _a.slug) {
        this._traceUrl = buildTraceUrl(apikey, serviceName, (_b = respData.team) === null || _b === void 0 ? void 0 : _b.slug, (_c = respData.environment) === null || _c === void 0 ? void 0 : _c.slug, uiRoot);
      } else {
        throw new Error();
      }
    }).catch(() => {
      if (this._logLevel >= api.DiagLogLevel.INFO) {
        console.log(FAILED_AUTH_FOR_LOCAL_VISUALIZATIONS);
      }
    });
  }
  export(spans, resultCallback) {
    if (this._traceUrl) {
      spans.forEach(span => {
        var _a;
        // only log root spans (ones without a parent span)
        if (!((_a = span.parentSpanContext) === null || _a === void 0 ? void 0 : _a.spanId) && this._logLevel >= api.DiagLogLevel.INFO) {
          console.log(createHoneycombSDKLogMessage(`Honeycomb link: ${this._traceUrl}=${span.spanContext().traceId}`));
        }
      });
    }
    resultCallback({
      code: core.ExportResultCode.SUCCESS
    });
  }
  shutdown() {
    return Promise.resolve();
  }
}
/**
 * Builds and returns a URL that is used to log when a trace is completed in the {@link ConsoleTraceLinkExporter}.
 *
 * @param apikey the Honeycomb API key used to retrieve the Honeycomb team and environment
 * @param serviceName the Honeycomb service name (or classic dataset) where data is stored
 * @param team the Honeycomb team
 * @param environment the Honeycomb environment
 * @returns
 */
function buildTraceUrl(apikey, serviceName, team, environment, uiRoot) {
  let url = `${uiRoot}/${team}`;
  if (!isClassic(apikey) && environment) {
    url += `/environments/${environment}`;
  }
  url += `/datasets/${serviceName}/trace?trace_id`;
  return url;
}

function configureTraceExporters(options) {
  const honeycombTraceExporters = [];
  if (options === null || options === void 0 ? void 0 : options.localVisualizations) {
    honeycombTraceExporters.push(configureConsoleTraceLinkExporter(options));
  }
  // if there is a user-provided exporter, add to the composite exporter
  if (options === null || options === void 0 ? void 0 : options.traceExporter) {
    honeycombTraceExporters.push(options === null || options === void 0 ? void 0 : options.traceExporter);
  }
  // if there is an array of user-provided exporters, add them to the composite exporter
  // This will override the default honeycomb trace exporter.
  if (options === null || options === void 0 ? void 0 : options.traceExporters) {
    honeycombTraceExporters.push(...options.traceExporters);
  }
  // Disable this if a configuration option is present
  if ((options === null || options === void 0 ? void 0 : options.disableDefaultTraceExporter) !== true) {
    honeycombTraceExporters.unshift(configureHoneycombHttpJsonTraceExporter(options));
  }
  return configureCompositeExporter([...honeycombTraceExporters]);
}
function configureMetricExporters(options) {
  const exporters = [];
  // if there is an array of user-provided exporters, add them
  if (options === null || options === void 0 ? void 0 : options.metricExporters) {
    exporters.push(...options.metricExporters);
  }
  if ((options === null || options === void 0 ? void 0 : options.disableDefaultMetricExporter) !== true) {
    exporters.unshift(configureHoneycombHttpJsonMetricExporter(options));
  }
  if (options === null || options === void 0 ? void 0 : options.localVisualizations) {
    // TODO: Create a console link exporter for metrics.
    exporters.push(new ConsoleMetricExporter());
  }
  return exporters;
}
function configureLogExporters(options) {
  const exporters = [];
  exporters.push(configureHoneycombHttpJsonLogExporter(options));
  if (options === null || options === void 0 ? void 0 : options.localVisualizations) {
    // TODO: Create a console link exporter for logs.
    exporters.push(new ConsoleLogRecordExporter());
  }
  return exporters;
}
/**
 * Builds and returns a new {@link SpanExporter} that wraps the provided array
 * of {@link SpanExporter}s
 *
 * @param exporters the exporters to wrap with the composite exporter
 * @returns the configured {@link SpanExporter} instance
 */
function configureCompositeExporter(exporters) {
  return new CompositeSpanExporter(exporters);
}
/**
 * A custom SpanExporter that wraps a number of other exporters and calls export and shutdown
 * for each.
 */
class CompositeSpanExporter {
  constructor(exporters) {
    this._exporters = exporters;
  }
  export(spans, resultCallback) {
    this._exporters.forEach(exporter => exporter.export(spans, resultCallback));
    resultCallback({
      code: core.ExportResultCode.SUCCESS
    });
  }
  async shutdown() {
    const results = [];
    this._exporters.forEach(exporter => results.push(exporter.shutdown()));
    await Promise.all(results);
  }
}

/**
 * A {@link SpanProcessor} that reads entries stored in {@link Baggage}
 * from the parent context and adds the baggage entries' keys and values
 * to the span as attributes on span start.
 *
 * Keys and values added to Baggage will appear on subsequent child
 * spans for a trace within this service *and* be propagated to external
 * services in accordance with any configured propagation formats
 * configured. If the external services also have a Baggage span
 * processor, the keys and values will appear in those child spans as
 * well.
 *
 * ⚠ Warning ⚠️
 *
 * Do not put sensitive information in Baggage.
 *
 * To repeat: a consequence of adding data to Baggage is that the keys and
 * values will appear in all outgoing HTTP headers from the application.
 */
class BaggageSpanProcessor {
  constructor() {}
  onStart(span, parentContext) {
    var _a, _b;
    ((_b = (_a = api.propagation.getBaggage(parentContext)) === null || _a === void 0 ? void 0 : _a.getAllEntries()) !== null && _b !== void 0 ? _b : []).forEach(entry => {
      span.setAttribute(entry[0], entry[1].value);
      api.diag.debug(`@honeycombio/opentelemetry-web: 🚨 Baggage in all outgoing headers: ${entry[0]}=${entry[1].value} `);
    });
  }
  onEnd() {}
  forceFlush() {
    return Promise.resolve();
  }
  shutdown() {
    return Promise.resolve();
  }
}

/**
 * A {@link SpanProcessor} that adds browser specific attributes to each span
 * that might change over the course of a session.
 * Static attributes (e.g. User Agent) are added to the Resource.
 */
class BrowserAttributesSpanProcessor {
  constructor() {}
  onStart(span) {
    const {
      href,
      pathname,
      search,
      hash,
      hostname
    } = window.location;
    span.setAttributes({
      [ATTR_BROWSER_WIDTH]: window.innerWidth,
      [ATTR_BROWSER_HEIGHT]: window.innerHeight,
      [ATTR_PAGE_HASH]: hash,
      [ATTR_PAGE_URL]: href,
      [ATTR_PAGE_ROUTE]: pathname,
      [ATTR_PAGE_HOSTNAME]: hostname,
      [ATTR_PAGE_SEARCH]: search,
      [ATTR_URL_PATH]: pathname
    });
  }
  onEnd() {}
  forceFlush() {
    return Promise.resolve();
  }
  shutdown() {
    return Promise.resolve();
  }
}

const generator = new sdkTraceBase.RandomIdGenerator();
const sessionId = generator.generateTraceId();
const defaultSessionProvider = {
  getSessionId: () => sessionId
};

// TODO: we might not need this anymore if the top level tracer provider supports multiple span processors!
/**
 * Builds and returns an array of Span Processors that includes the BatchSpanProcessor, BrowserSpanProcessor,
 * BaggageSpanProcessor, and optionally user provided Span Processors.
 * @param options The {@link HoneycombOptions}
 * @returns {@link SpanProcessor[]}
 */
const configureSpanProcessors = options => {
  const processors = [];
  if (!(options === null || options === void 0 ? void 0 : options.disableBrowserAttributes)) {
    processors.push(new BrowserAttributesSpanProcessor());
  }
  processors.push(new BaggageSpanProcessor(), webCommon.createSessionSpanProcessor((options === null || options === void 0 ? void 0 : options.sessionProvider) || defaultSessionProvider), ...((options === null || options === void 0 ? void 0 : options.spanProcessors) || []));
  return processors;
};

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *///----------------------------------------------------------------------------------------------------------
// DO NOT EDIT, this is an Auto-generated file from scripts/semconv/templates/registry/stable/attributes.ts.j2
//----------------------------------------------------------------------------------------------------------
/**
 * Preferred language of the user using the browser
 *
 * @example en
 * @example en-US
 * @example fr
 * @example fr-FR
 *
 * @note This value is intended to be taken from the Navigator API `navigator.language`.
 *
 * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.
 */const ATTR_BROWSER_LANGUAGE='browser.language';/**
 * A boolean that is true if the browser is running on a mobile device
 *
 * @note This value is intended to be taken from the [UA client hints API](https://wicg.github.io/ua-client-hints/#interface) (`navigator.userAgentData.mobile`). If unavailable, this attribute **SHOULD** be left unset.
 *
 * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.
 */const ATTR_BROWSER_MOBILE='browser.mobile';/**
 * The name of the auto instrumentation agent or distribution, if used.
 *
 * @example parts-unlimited-java
 *
 * @note Official auto instrumentation agents and distributions **SHOULD** set the `telemetry.distro.name` attribute to
 * a string starting with `opentelemetry-`, e.g. `opentelemetry-java-instrumentation`.
 *
 * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.
 */const ATTR_TELEMETRY_DISTRO_NAME='telemetry.distro.name';/**
 * The version string of the auto instrumentation agent or distribution, if used.
 *
 * @example 1.2.3
 *
 * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.
 */const ATTR_TELEMETRY_DISTRO_VERSION='telemetry.distro.version';

function configureHoneycombResource() {
  return resources.resourceFromAttributes({
    [ATTR_HONEYCOMB_DISTRO_VERSION]: userInteractionInstrumentation.VERSION,
    [ATTR_HONEYCOMB_DISTRO_RUNTIME_VERSION]: 'browser',
    [ATTR_TELEMETRY_DISTRO_NAME]: '@honeycombio/opentelemetry-web',
    [ATTR_TELEMETRY_DISTRO_VERSION]: userInteractionInstrumentation.VERSION
  });
}

const defaultConfig = {
  path: true,
  hash: true,
  hostname: true,
  referrer: true,
  url: false,
  search: false
};
function configureEntryPageResource(config) {
  if (config === false || !(window === null || window === void 0 ? void 0 : window.location)) {
    return resources.resourceFromAttributes({});
  }
  const options = getOptions(config);
  const {
    href,
    pathname,
    search,
    hash,
    hostname
  } = window.location;
  const attributes = {
    [ATTR_ENTRY_PAGE_URL]: optionalAttribute(options.url, href),
    [ATTR_ENTRY_PAGE_PATH]: optionalAttribute(options.path, pathname),
    [ATTR_ENTRY_PAGE_SEARCH]: optionalAttribute(options.search, search),
    [ATTR_ENTRY_PAGE_HASH]: optionalAttribute(options.hash, hash),
    [ATTR_ENTRY_PAGE_HOSTNAME]: optionalAttribute(options.hostname, hostname),
    [ATTR_ENTRY_PAGE_REFERRER]: optionalAttribute(options.referrer, document.referrer)
  };
  return resources.resourceFromAttributes(attributes);
}
function getOptions(config) {
  if (!config) {
    return defaultConfig;
  }
  return Object.assign(Object.assign({}, defaultConfig), config);
}
function optionalAttribute(shouldInclude, attribute) {
  if (!shouldInclude) {
    return undefined;
  }
  return attribute;
}

const computeScreenSize = screenWidth => {
  if (screenWidth <= 768) return 'small';else if (screenWidth > 768 && screenWidth <= 1024) return 'medium';else if (screenWidth > 1024) return 'large';
  return 'unknown';
};
const computeNetworkType = networkInformation => {
  var _a;
  return (_a = networkInformation === null || networkInformation === void 0 ? void 0 : networkInformation.effectiveType) !== null && _a !== void 0 ? _a : 'unknown';
};
const computeDeviceType = (detectedDeviceType, detectedBrowserName) => {
  // ua-parser-js doesn't fill in device type unless it's in the user agent directly
  // which means that desktops/laptops show up as undefined
  // https://github.com/faisalman/ua-parser-js/issues/182
  //
  // we're going to do this:
  // browser name & device type both undefined -> unknown
  // browser name defined & device type undefined -> desktop
  // device type defined -> use that
  if (!detectedDeviceType && !detectedBrowserName) {
    return 'unknown';
  }
  if (!detectedDeviceType) {
    return 'desktop';
  }
  return detectedDeviceType;
};
const computeDeviceProperties = userAgent => {
  const uaParser = new UAParser(userAgent);
  const {
    name: browserName,
    version: browserVersion
  } = uaParser.getBrowser();
  return {
    browserName: browserName !== null && browserName !== void 0 ? browserName : 'unknown',
    browserVersion: browserVersion !== null && browserVersion !== void 0 ? browserVersion : 'unknown',
    deviceType: computeDeviceType(uaParser.getDevice().type, browserName)
  };
};
function configureBrowserAttributesResource() {
  const {
    browserName,
    browserVersion,
    deviceType
  } = computeDeviceProperties(navigator.userAgent);
  const browserAttributes = {
    [semanticConventions.ATTR_USER_AGENT_ORIGINAL]: navigator.userAgent,
    //https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent#mobile_tablet_or_desktop
    [ATTR_BROWSER_MOBILE]: navigator.userAgent.includes('Mobi'),
    [ATTR_BROWSER_TOUCH_SCREEN_ENABLED]: navigator.maxTouchPoints > 0,
    [ATTR_BROWSER_LANGUAGE]: navigator.language,
    [ATTR_BROWSER_NAME]: browserName,
    [ATTR_BROWSER_VERSION]: browserVersion,
    [ATTR_DEVICE_TYPE]: deviceType,
    [ATTR_NETWORK_EFFECTIVE_TYPE]: computeNetworkType(navigator.connection),
    [ATTR_SCREEN_WIDTH]: window.screen.width,
    [ATTR_SCREEN_HEIGHT]: window.screen.height,
    [ATTR_SCREEN_SIZE]: computeScreenSize(window.screen.width)
  };
  return resources.resourceFromAttributes(browserAttributes);
}

/**
 * This function combines resource attributes we provide from this SDK with attributes provided
 * by the user in the options. It merges them together and returns a single resource.
 * @param options - Honeycomb options
 * @returns Resource - The resource with the configured attributes
 */
const configureResourceAttributes = options => {
  let resource = resources.resourceFromAttributes({});
  if (!(options === null || options === void 0 ? void 0 : options.disableBrowserAttributes)) {
    resource = resource.merge(configureEntryPageResource(options === null || options === void 0 ? void 0 : options.entryPageAttributes)).merge(configureBrowserAttributesResource());
  }
  resource = resource.merge(configureHoneycombResource());
  if (options === null || options === void 0 ? void 0 : options.resource) {
    resource = resource.merge(options.resource);
  }
  if (options === null || options === void 0 ? void 0 : options.resourceAttributes) {
    resource = resource.merge(resources.resourceFromAttributes(options.resourceAttributes));
  }
  return resource;
};

class HoneycombWebSDK extends WebSDK {
  constructor(options) {
    var _a, _b;
    const instrumentations = [...((options === null || options === void 0 ? void 0 : options.instrumentations) || [])];
    // Automatically include web vitals instrumentation unless explicitly set to false
    if (((_a = options === null || options === void 0 ? void 0 : options.webVitalsInstrumentationConfig) === null || _a === void 0 ? void 0 : _a.enabled) !== false) {
      instrumentations.push(new WebVitalsInstrumentation(options === null || options === void 0 ? void 0 : options.webVitalsInstrumentationConfig));
    }
    // Automatically include global errors instrumentation unless explicitly set to false
    if (((_b = options === null || options === void 0 ? void 0 : options.globalErrorsInstrumentationConfig) === null || _b === void 0 ? void 0 : _b.enabled) !== false) {
      instrumentations.push(new GlobalErrorsInstrumentation(options === null || options === void 0 ? void 0 : options.globalErrorsInstrumentationConfig));
    }
    super(Object.assign(Object.assign({}, options), {
      instrumentations,
      resource: configureResourceAttributes(options),
      sampler: configureSampler(options),
      spanProcessors: configureSpanProcessors(options),
      traceExporter: configureTraceExporters(options),
      metricExporters: configureMetricExporters(options),
      logExporters: configureLogExporters(options)
    }));
    validateOptionsWarnings(options);
    if (options === null || options === void 0 ? void 0 : options.debug) {
      configureDebug(options);
    }
  }
}

exports.UserInteractionInstrumentation = userInteractionInstrumentation.UserInteractionInstrumentation;
exports.ATTR_BROWSER_HEIGHT = ATTR_BROWSER_HEIGHT;
exports.ATTR_BROWSER_NAME = ATTR_BROWSER_NAME;
exports.ATTR_BROWSER_TOUCH_SCREEN_ENABLED = ATTR_BROWSER_TOUCH_SCREEN_ENABLED;
exports.ATTR_BROWSER_VERSION = ATTR_BROWSER_VERSION;
exports.ATTR_BROWSER_WIDTH = ATTR_BROWSER_WIDTH;
exports.ATTR_CLS_DELTA = ATTR_CLS_DELTA;
exports.ATTR_CLS_ELEMENT = ATTR_CLS_ELEMENT;
exports.ATTR_CLS_HAD_RECENT_INPUT = ATTR_CLS_HAD_RECENT_INPUT;
exports.ATTR_CLS_ID = ATTR_CLS_ID;
exports.ATTR_CLS_LARGEST_SHIFT_TARGET = ATTR_CLS_LARGEST_SHIFT_TARGET;
exports.ATTR_CLS_LARGEST_SHIFT_TIME = ATTR_CLS_LARGEST_SHIFT_TIME;
exports.ATTR_CLS_LARGEST_SHIFT_VALUE = ATTR_CLS_LARGEST_SHIFT_VALUE;
exports.ATTR_CLS_LOAD_STATE = ATTR_CLS_LOAD_STATE;
exports.ATTR_CLS_NAVIGATION_TYPE = ATTR_CLS_NAVIGATION_TYPE;
exports.ATTR_CLS_RATING = ATTR_CLS_RATING;
exports.ATTR_CLS_VALUE = ATTR_CLS_VALUE;
exports.ATTR_DEVICE_TYPE = ATTR_DEVICE_TYPE;
exports.ATTR_ENTRY_PAGE_HASH = ATTR_ENTRY_PAGE_HASH;
exports.ATTR_ENTRY_PAGE_HOSTNAME = ATTR_ENTRY_PAGE_HOSTNAME;
exports.ATTR_ENTRY_PAGE_PATH = ATTR_ENTRY_PAGE_PATH;
exports.ATTR_ENTRY_PAGE_REFERRER = ATTR_ENTRY_PAGE_REFERRER;
exports.ATTR_ENTRY_PAGE_SEARCH = ATTR_ENTRY_PAGE_SEARCH;
exports.ATTR_ENTRY_PAGE_URL = ATTR_ENTRY_PAGE_URL;
exports.ATTR_FCP_DELTA = ATTR_FCP_DELTA;
exports.ATTR_FCP_ID = ATTR_FCP_ID;
exports.ATTR_FCP_LOAD_STATE = ATTR_FCP_LOAD_STATE;
exports.ATTR_FCP_NAVIGATION_TYPE = ATTR_FCP_NAVIGATION_TYPE;
exports.ATTR_FCP_RATING = ATTR_FCP_RATING;
exports.ATTR_FCP_TIME_SINCE_FIRST_BYTE = ATTR_FCP_TIME_SINCE_FIRST_BYTE;
exports.ATTR_FCP_TIME_TO_FIRST_BYTE = ATTR_FCP_TIME_TO_FIRST_BYTE;
exports.ATTR_FCP_VALUE = ATTR_FCP_VALUE;
exports.ATTR_HONEYCOMB_DISTRO_RUNTIME_VERSION = ATTR_HONEYCOMB_DISTRO_RUNTIME_VERSION;
exports.ATTR_HONEYCOMB_DISTRO_VERSION = ATTR_HONEYCOMB_DISTRO_VERSION;
exports.ATTR_INP_DELTA = ATTR_INP_DELTA;
exports.ATTR_INP_DURATION = ATTR_INP_DURATION;
exports.ATTR_INP_ELEMENT = ATTR_INP_ELEMENT;
exports.ATTR_INP_EVENT_TYPE = ATTR_INP_EVENT_TYPE;
exports.ATTR_INP_ID = ATTR_INP_ID;
exports.ATTR_INP_INPUT_DELAY = ATTR_INP_INPUT_DELAY;
exports.ATTR_INP_INTERACTION_TARGET = ATTR_INP_INTERACTION_TARGET;
exports.ATTR_INP_INTERACTION_TIME = ATTR_INP_INTERACTION_TIME;
exports.ATTR_INP_INTERACTION_TYPE = ATTR_INP_INTERACTION_TYPE;
exports.ATTR_INP_LOAD_STATE = ATTR_INP_LOAD_STATE;
exports.ATTR_INP_NAVIGATION_TYPE = ATTR_INP_NAVIGATION_TYPE;
exports.ATTR_INP_NEXT_PAINT_TIME = ATTR_INP_NEXT_PAINT_TIME;
exports.ATTR_INP_PRESENTATION_DELAY = ATTR_INP_PRESENTATION_DELAY;
exports.ATTR_INP_PROCESSING_DURATION = ATTR_INP_PROCESSING_DURATION;
exports.ATTR_INP_RATING = ATTR_INP_RATING;
exports.ATTR_INP_SCRIPT_DURATION = ATTR_INP_SCRIPT_DURATION;
exports.ATTR_INP_SCRIPT_ENTRY_TYPE = ATTR_INP_SCRIPT_ENTRY_TYPE;
exports.ATTR_INP_SCRIPT_EXECUTION_START = ATTR_INP_SCRIPT_EXECUTION_START;
exports.ATTR_INP_SCRIPT_FORCED_STYLE_AND_LAYOUT_DURATION = ATTR_INP_SCRIPT_FORCED_STYLE_AND_LAYOUT_DURATION;
exports.ATTR_INP_SCRIPT_INVOKER = ATTR_INP_SCRIPT_INVOKER;
exports.ATTR_INP_SCRIPT_PAUSE_DURATION = ATTR_INP_SCRIPT_PAUSE_DURATION;
exports.ATTR_INP_SCRIPT_SOURCE_CHAR_POSITION = ATTR_INP_SCRIPT_SOURCE_CHAR_POSITION;
exports.ATTR_INP_SCRIPT_SOURCE_FUNCTION_NAME = ATTR_INP_SCRIPT_SOURCE_FUNCTION_NAME;
exports.ATTR_INP_SCRIPT_SOURCE_URL = ATTR_INP_SCRIPT_SOURCE_URL;
exports.ATTR_INP_SCRIPT_START_TIME = ATTR_INP_SCRIPT_START_TIME;
exports.ATTR_INP_SCRIPT_WINDOW_ATTRIBUTION = ATTR_INP_SCRIPT_WINDOW_ATTRIBUTION;
exports.ATTR_INP_TIMING_DURATION = ATTR_INP_TIMING_DURATION;
exports.ATTR_INP_TIMING_ENTRY_TYPE = ATTR_INP_TIMING_ENTRY_TYPE;
exports.ATTR_INP_TIMING_NAME = ATTR_INP_TIMING_NAME;
exports.ATTR_INP_TIMING_RENDER_START = ATTR_INP_TIMING_RENDER_START;
exports.ATTR_INP_TIMING_START_TIME = ATTR_INP_TIMING_START_TIME;
exports.ATTR_INP_VALUE = ATTR_INP_VALUE;
exports.ATTR_LCP_DELTA = ATTR_LCP_DELTA;
exports.ATTR_LCP_ELEMENT = ATTR_LCP_ELEMENT;
exports.ATTR_LCP_ELEMENT_RENDER_DELAY = ATTR_LCP_ELEMENT_RENDER_DELAY;
exports.ATTR_LCP_ID = ATTR_LCP_ID;
exports.ATTR_LCP_NAVIGATION_TYPE = ATTR_LCP_NAVIGATION_TYPE;
exports.ATTR_LCP_RATING = ATTR_LCP_RATING;
exports.ATTR_LCP_RESOURCE_LOAD_DELAY = ATTR_LCP_RESOURCE_LOAD_DELAY;
exports.ATTR_LCP_RESOURCE_LOAD_DURATION = ATTR_LCP_RESOURCE_LOAD_DURATION;
exports.ATTR_LCP_RESOURCE_LOAD_TIME = ATTR_LCP_RESOURCE_LOAD_TIME;
exports.ATTR_LCP_TIME_TO_FIRST_BYTE = ATTR_LCP_TIME_TO_FIRST_BYTE;
exports.ATTR_LCP_URL = ATTR_LCP_URL;
exports.ATTR_LCP_VALUE = ATTR_LCP_VALUE;
exports.ATTR_NETWORK_EFFECTIVE_TYPE = ATTR_NETWORK_EFFECTIVE_TYPE;
exports.ATTR_PAGE_HASH = ATTR_PAGE_HASH;
exports.ATTR_PAGE_HOSTNAME = ATTR_PAGE_HOSTNAME;
exports.ATTR_PAGE_ROUTE = ATTR_PAGE_ROUTE;
exports.ATTR_PAGE_SEARCH = ATTR_PAGE_SEARCH;
exports.ATTR_PAGE_URL = ATTR_PAGE_URL;
exports.ATTR_SCREEN_HEIGHT = ATTR_SCREEN_HEIGHT;
exports.ATTR_SCREEN_SIZE = ATTR_SCREEN_SIZE;
exports.ATTR_SCREEN_WIDTH = ATTR_SCREEN_WIDTH;
exports.ATTR_TTFB_CACHE_DURATION = ATTR_TTFB_CACHE_DURATION;
exports.ATTR_TTFB_CONNECTION_DURATION = ATTR_TTFB_CONNECTION_DURATION;
exports.ATTR_TTFB_CONNECTION_TIME = ATTR_TTFB_CONNECTION_TIME;
exports.ATTR_TTFB_DELTA = ATTR_TTFB_DELTA;
exports.ATTR_TTFB_DNS_DURATION = ATTR_TTFB_DNS_DURATION;
exports.ATTR_TTFB_DNS_TIME = ATTR_TTFB_DNS_TIME;
exports.ATTR_TTFB_ID = ATTR_TTFB_ID;
exports.ATTR_TTFB_NAVIGATION_TYPE = ATTR_TTFB_NAVIGATION_TYPE;
exports.ATTR_TTFB_RATING = ATTR_TTFB_RATING;
exports.ATTR_TTFB_REQUEST_DURATION = ATTR_TTFB_REQUEST_DURATION;
exports.ATTR_TTFB_REQUEST_TIME = ATTR_TTFB_REQUEST_TIME;
exports.ATTR_TTFB_VALUE = ATTR_TTFB_VALUE;
exports.ATTR_TTFB_WAITING_DURATION = ATTR_TTFB_WAITING_DURATION;
exports.ATTR_TTFB_WAITING_TIME = ATTR_TTFB_WAITING_TIME;
exports.ATTR_URL_PATH = ATTR_URL_PATH;
exports.BaggageSpanProcessor = BaggageSpanProcessor;
exports.GlobalErrorsInstrumentation = GlobalErrorsInstrumentation;
exports.HoneycombWebSDK = HoneycombWebSDK;
exports.WebSDK = WebSDK;
exports.WebVitalsInstrumentation = WebVitalsInstrumentation;
exports.recordException = recordException;
